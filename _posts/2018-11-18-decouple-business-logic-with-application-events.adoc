---
compatible_cuba_versions: 7.0
project_id: cuba-petclinic-intro-to-application-events
permalink: decouple-business-logic-with-app-events
---
= Decouple business logic with application events
:showtitle:
:page-navtitle: Decouple business logic with application events
:page-excerpt: Overview on how application events can be used in a CUBA application to decouple business logic
:page-root: ../../../
:project_id: cuba-petclinic-intro-to-application-events
:java_version: 1.8
:cuba_version: 7.0

This guide walks you through the CUBA mechanism to use events in your application. In CUBA 7 events are the predominant mechanism to react to different kinds of changes of the application. Furthermore events are a common pattern within an application to decouple one part of the business logic from another.


== What will be build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA petclinic] example to show different use cases of application events. In particular, the following use cases will be covered:

* sending out of Room keycode for booked visits
* kicking off payment process once Pet Visit is marked as completed

=== Final Application

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-datamanager/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-datamanager/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]

== Benefits of a event based business logic

The most common approach of communicating between application logic is to do method invocation. In CUBA and Spring this is done via Java objects interacting with each other, Spring components & CUBA services. There are good reasons to use this functionality, but it is not the only one. Furthermore this pattern of method invocation is oftentimes overused which can lead to bad maintainability of the overall system due to highly coupled application parts.

Event based business logic is an alternative communication pattern for application logic, that has particular strengths in its low coupling of the parts. It is not suitable for all kinds of communication patterns, but for a big number of cases it is a viable alternative. Generally event based communication can be used in the following scenarios:

* notification style communication
* communication that not necessary needs a back-channel
* triggering between technical independent parts of application logic
* situations where the user doesn't need an immediate response

As a result of using event based communication the parts of the application that are leveraging it will gain the following properties:

* low coupling from the event sender to the receiver
* easy isolated testability of the sender and receiver
* increased resiliency of the sender


== Available types of events in a CUBA application

There are different kinds of application events within a CUBA application. The main categories are:

* CUBA entity lifecycle events
* CUBA application lifecycle events
* CUBA application events
* custom application events

In this guide there are examples for using an entity lifecycle event as well as creating a custom application event.

=== Entity Lifecycle events: EntityChangedEvent


In the petclinic example following logic will be implemented: The petclinic has rooms for the stay of the pets during their time in the clinic. The rooms have no traditional keys or keycards, but instead have a 6 digit keycode to enter at the entrace door. This keycode has to be given to the pets owner once a new visit is booked. The transportation of the keycode should happen via SMS notification from the application.

This example is in the category of _Entity lifecycle events_. The `EntityChangedEvent` is send out by the CUBA storage mechanism, once an Entity has been changed in the database: because we want to execute logic, once a visit is booked (created).

CUBA fires such an Event for entities, that have an annotation `@PublishEntityChangedEvents` on the Entity definition. A `EntityChangedEvent` contains information about the type of change (create, update or delete) as well as the attributes which have been changed.

To register a Event listener for this event, a new Spring bean in the core module of the application has to be defined. In order to register to a specific kind of event, the method that should be called once an `EntityChangedEvent` has been send has to be annotated with `@TransactionalEventListener`.


.RoomKeycodeToOwnerSender.java
[source,java]
----

@Component("petclinic_roomKeycodeToOwnerSender")
public class RoomKeycodeToOwnerSender {

    @Inject
    private DataManager dataManager;

    @Inject
    private MobilePhoneNotificationGateway mobilePhoneNotificationGateway;

    @TransactionalEventListener // <1>
    public void sendRoomKeycode(EntityChangedEvent<Visit, UUID> event) { // <2>

        if (event.getType().equals(EntityChangedEvent.Type.CREATED)) {
            Visit visit = loadVisit(event.getEntityId()); // <3>
            tryToSendRoomKeycodeToPetsOwner(visit);
        }
    }

    private void tryToSendRoomKeycodeToPetsOwner(Visit visit) {


        if (visit.getPet().getOwner() != null) {

            String phoneNumber = visit.getPet().getOwner().getTelephone();

            if (phoneNumber != null) {
                String notificationText = createNotificationText(visit);

                mobilePhoneNotificationGateway.sendNotification(phoneNumber, notificationText);
            }
        }

    }


    // ...

}
----

<1> registration of `sendRoomKeycode` as an event listener
<2> scoping `EntityChangedEvent` only to Events which changed `Visit` entities
<3> access to `Visit` identifier of the created instance


With this definition of the Event listener the application will send out room keycodes to the owners of pets that have just registered in the petclinic.

There can be multiple event listeners defined for a given event. In this example it is also required to not only notify the Owner of the pet about the keycode, but also the system that is responsible for controlling the door hardware. It also needs additional information about the visit with the associated pet, to automatically adjust the height of the bed, display a welcome message on the rooms TV etc.

The following event listener will take over the responsibility to notify the room system.


.RoomSystemNotifier.java
[source,java]
----

@Component("petclinic_roomSystemNotifier")
public class RoomSystemNotifier {

    @Inject
    private DataManager dataManager;

    @Inject
    RoomSystemGateway roomSystemGateway;

    @TransactionalEventListener
    public void notifyRoomSystem(EntityChangedEvent<Visit, UUID> event) {

        if (event.getType().equals(EntityChangedEvent.Type.CREATED)) {
            Visit visit = loadVisit(event.getEntityId());
            tryToNotifyRoomSystemAboutVisit(visit);
        }
    }

    private void tryToNotifyRoomSystemAboutVisit(Visit visit) {
        roomSystemGateway.informAboutVisit(visit);
    }

    // ...
}
----


==== Naming Conventions of events

Events are normally named in simple past: "Entity *Changed* Event". This is a common pattern, because it stresses that an event is a immutable fact that happened in the past and is not changeable anymore. Event listeners on the other hand should be named in present tense.

Furthermore Event listeners are normally named regarding the one specific action that they should fulfill. Instead of create a general `PetCreatedListener` that deals with all things that should happen once a pet is created in the system, Event listeners should be named regarding one specific action that should be performed: `RoomKeycodeToOwnerSender` -> sends a room keycode to the pets owner.

This is an example of an application of the https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle[open-closed principle], which normally lead to more loosely coupled application and due to that to more maintainable software.


=== Custom Application Logic events

The last example is using custom application events to send message between different parts of the application in a loosely coupled manner. When the pet is recovered and checks out the visit is marked as complete. When this event happens, certain downstream process can be kicked of as well. One of them, which this example deals with is that the invoicing process kicks in.

The first step towards custom application event is to define a event as a class `VisitCompletedEvent` in the `core` module:

.VisitCompletedEvent.java
[source,java]
----
package com.haulmont.sample.petclinic.core.visit;

public class VisitCompletedEvent extends ApplicationEvent { // <1>

    public VisitCompletedEvent(Visit source) { // <2>
        super(source);
    }

    @Override
    public Visit getSource() {
        return (Visit) super.getSource();
    }
}
----

<1> Custom events have to extend `ApplicationEvent` in order to being passed through the event system of Spring
<2> The source of the event is set to an `Visit` instance

The next part is to send the event using the `Events` infrastructure of CUBA.


.VisitStatusServiceBean.java
[source,java]
----
package com.haulmont.sample.petclinic.service;

import com.haulmont.cuba.core.global.Events;

// ...

@Service(VisitStatusService.NAME)
public class VisitStatusServiceBean implements VisitStatusService {

    @Inject
    private Events events; // <1>

    // ...

    @Override
    public boolean completeVisit(Visit visit) {

        if (visit.getStatus().equals(VisitStatus.ACTIVE)) {
            markVisitAsComplete(visit);

            notifyAboutVisitCompletion(visit);

            return true;
        }

        // ...
    }

    private void notifyAboutVisitCompletion(Visit visit) {
        events.publish(new VisitCompletedEvent(visit)); // <2>
    }

    private void markVisitAsComplete(Visit visit) {
        visit.setStatus(VisitStatus.COMPLETED);
        dataManager.commit(visit);
        log.info("Visit {} marked as complete", visit);
    }
}
----

<1> Injecting CUBAs `Events` Spring bean
<2> publishing a new `VisitCompletedEvent` once the visit's status is updated

The last remaining part looks exactly the same as for other events that are published by CUBA itself - since the technical mechanisms are exactly the same.

The Event listener `InvoicingProcessInitializer` receives events of type `VisitCompletedEvent` and create an invoice for the received visit.

TIP: there are two ways to listen to events. Above `@TransactionalEventListener` annotation is used. There is also the possibility to implement the Interface `ApplicationListener<T>` which is used for the Event listener `InvoicingProcessInitializer`.


.InvoicingProcessInitializer.java
[source,java]
----
package com.haulmont.sample.petclinic.core.payment;

@Component("petclinic_invoicingProcessInitializer")
public class InvoicingProcessInitializer implements ApplicationListener<VisitCompletedEvent> {

    // ...

    @Override
    public void onApplicationEvent(VisitCompletedEvent event) {
        log.info("Payment process initialized: {}", event.getSource());

        CommitContext commitContext = new CommitContext();
        createInvoiceFor(event.getSource(), commitContext);

        dataManager.commit(commitContext);
    }

    private void createInvoiceFor(Visit visit, CommitContext commitContext) {
        Invoice invoice = dataManager.create(Invoice.class);

        invoice.setVisit(visit);
        invoice.setInvoiceDate(visit.getVisitDate());
        invoice.setInvoiceNumber(createInvoiceNumber());

        List<InvoiceItem> invoiceItems = createInvoiceItemsFor(invoice);
        invoice.setItems(invoiceItems);

        invoiceItems.forEach(commitContext::addInstanceToCommit);
        commitContext.addInstanceToCommit(invoice);

    }

    //...

}
----


=== Sending events between layers within an CUBA application


Technically there is one main constraints to think about when interacting with events in a CUBA application. This is that as CUBA is a multi module application that can be deployed as two main parts: frontend (web module) and middleware (core module) sending events between the two layers is not directly possible.

The underlying framework for the events mechanism is Spring, which has the facility to send application events within one application, especially within one JVM process. Since frontend and middleware can be two different JVM processes on different servers, Spring by default has no capabilities to interact between JVM processes.

There are two ways to solve this problem. The first one is to leverage an external message broker like RabbitMQ to interact between applications (or layers of applications in this case). An internal application event can be send internally. An event listener (e.g. `RabbitMqForwarder`) then takes this message and forwards it to the external message broker. On the receiver side another Event listener for external RabbitMQ messages converts the messages to internal CUBA / Spring messages. With that the application can transparently communicate between JVM boundaries.

The other way is to use an existing application component called `global-events`. Global events is an application component from Haulmont that especially addresses the problem of communicating between CUBA middleware and frontend parts.



== Summary

Communicating via events can sometimes be a challenge to gets ones developers head around. Method calls allow to have a back-channel as a response. This is normally not the case for events. Also identifiying that certain parts can be executed independent of each other is not obvious at first sight.

One could argue that in the example from above the room keycode to the pets owner should only be send if the room system also knows about it and has configured everything properly. This natural wish for consistency is oftentimes very hard to achieve in a distributed system (as the petclinic management and room system are). Messaging in this regard increases the resiliency of the overall system and its parts on the costs of some potential consistency.

Application events in CUBA allow to define loosely coupled business logic within the application. Independent parts from a business functionality point of view can also be reflected as independent components within the application. This low coupling has certain advantages like easier testability and higher resilient of the parts of the application.

Ultimately, doing it right, prevents application logic to end up in a big ball of mud where there are calls between business logic from any parts of the system to any other parts of the system. Sending messages between application parts is a more maintainable way of arranging application logic and oftentimes represents the workflows of the problem domain in a more accurate way as they exists in the real world.


=== Further information

