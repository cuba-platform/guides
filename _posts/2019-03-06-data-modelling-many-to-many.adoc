---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-data-model-many-to-many
permalink: data-modelling-many-to-many-association
---
= 数据建模: 多对多关系
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Data Modelling: Many-to-Many Association
:page-excerpt: Data modelling guide: what are Many-to-Many associations and when to use them
:page-icone: images/data-model-many-to-many/guide_icone.svg
:page-root: ../../../
:project_id: cuba-petclinic-data-model-many-to-many
:page-url-first-image: https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-many-to-many/master/img/login-screen.png
:java_version: 1.8
:cuba_version: 7.0


多对多关系实现了一表条多记录与另一个表的多条记录关联。 关联表中将存储两个关联实体的主键。这个表中也可以包含其它附加列。

根据是否需要在关联表中包含附加列，多对多关系的实现有两种方式，即添加一个附加的实体或不添加附加实体。下面的示例演示这两种方式。

== 将要构建的内容

这个向导对 https://github.com/cuba-platform/cuba-petclinic[CUBA 宠物诊所] 示例进行了增强，以演示多对多关系的用法。以下用例会重点演示：

* `Vet` <--> `Specialty` 被建模为多对多关系，相应的UI也做了更新

* `Pet` <--> `InsuranceCompany` 被建模为间接的多对多关系，用了一个明确定义的实体来将两个实现建立关联，同时在这个实体中存储“有效范围” ????



=== 最终的应用程序

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-many-to-many/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-many-to-many/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]


== 直接的多对多关系

这里有一个宠物诊所应用中的一个直接多对多关系的示例：

image::data-model-many-to-many/direct_many_to_many.png[align="center"]


一个 `兽医（Vet）` 可以拥有多项 `专长(Speciality)`，另一方面一项专长也可以关联到多个兽医。

在数据库层面 ，这种关系表现为一个关联表，但是实体模型设计层面 ，_没有_一个明确定义的关联实体。


TIP: 在 Studio 提供的实体设计器中，给 `specialties` 属性做以下设置：
*Attribute type* - `ASSOCIATION`, *Cardinality* - `MANY_TO_MANY`. `Vet` 将被标记为关系的拥有方，同时 Studio 也会提示在 `Specialty` 实体中创建一个对应的  `vets`  属性作为关系反向引用。

https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/vet/Vet.java[Vet.java] -  `Vet` 实体包含一个名称为 `specialties` 、 被标记为多对多关系的列表属性。

.Vet.java
[source, java]
----
@JoinTable(name = "PETCLINIC_VET_SPECIALTY_LINK",
        joinColumns = @JoinColumn(name = "VET_ID"),
        inverseJoinColumns = @JoinColumn(name = "SPECIALTY_ID"))
@ManyToMany(mappedBy = "")
protected Set<Specialty> specialties;
----

https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/vet/Specialty.java[Specialty.java] -  `Specialty` 现在包含了一个标记为多对多关系的列表属性 `vets` ，设置如下： *Attribute type* - `ASSOCIATION`, *Cardinality* - `MANY_TO_MANY` 。

.Specialty.java
[source, java]
----
@JoinTable(name = "PETCLINIC_VET_SPECIALTY_LINK",
        joinColumns = @JoinColumn(name = "SPECIALTY_ID"),
        inverseJoinColumns = @JoinColumn(name = "VET_ID"))
@ManyToMany
protected List<Vet> vets;
----

`Specialty` 也默认被标记为关系的拥有方，这样在两边都可以修改关联的集合了。

* https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/views.xml[views.xml] - 兽医编辑界面使用的视图： `vet-with-specialties` 包含了关联属性： `specialties（专长）`，这个属性使用了 `_minimal` 视图。 视图 `specialty-with-vets` 同样也包含了 `vets(兽医)` 属性 。

* https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/vet/vet/vet-edit.xml[vet-edit.xml] - 兽医编辑界面的 XML 描述中为 `Vet` 实例定义了一个数据源，同时也为兽医的专长定义了一个嵌套数据源。界面上还有一个用于显示兽医专长的表格，表格上带有 https://doc.cuba-platform.com/manual-latest/list_actions.html#addAction[添加] 和 https://doc.cuba-platform.com/manual-latest/list_actions.html#removeAction[移除] 操作。

* https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/vet/specialty/specialty-edit.xml[specialty-edit.xml] - 专长编辑界面的XML 描述中为 `Specialty` 实例定义了一个数据源， 同时也为对应的兽医定义了一个嵌套数据源。界面上同样有表格和 *添加* 、 *移除* 操作。

所以 ，`Vet` 和 `Specialty` 编辑器是完全对称的。


== 使用关联实体的间接多对多关系

多对多关系都是使用一个关联表实现的，但是不是必须创建一个实体去对应这个表。如果需要在关联表中存储一些额外属性时，那么就需要创建一个关联实体。


下面是一个在宠物诊所示例中关于间接多对多关系的示例：

image::data-model-many-to-many/indirect_many_to_many.png[align="center"]

A `Pet` might over the years be insured by different `InsuranceCompanies` and an `InsuranceCompany` on the other hand has multiple memberships.

一个 `Pet` 每年可以不同的保险公司投保，另一方面，`InsuranceCompany（保险公司）` 也会有多个


在数据库中，这种关系表现为一个关联表，并且有一个显式定义的实体作为关联实体。投保关系中也要记录保险公司给宠物提供的保险范围。所以实体上有 `validFrom`  和 `validUntil` 属性。


TIP: In the Studio entity designer, set the following settings for the `insuranceMemberships` attribute: *Attribute type* - `COMPOSITION`, *Cardinality* - `ONE_TO_MANY`.

TIP: 在 Studio 提供的实体设计中, 为  `insuranceMemberships`  属性进行以下设置： *Attribute type* - `COMPOSITION` ， *Cardinality* - `ONE_TO_MANY`。

https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/pet/Pet.java[Pet.java] - `Pet` 实体包含一个一对多的 `InsuranceMembership` 实例组合。

.Pet.java
[source, java]
----
@Composition
@OnDelete(DeletePolicy.CASCADE)
@OneToMany(mappedBy = "pet")
protected List<InsuranceMembership> insurancesMemberships;
----

TIP: 在 Studio  提供的实体设计器中给 `memberships` 属性进行以下设置: *Attribute type* - `COMPOSITION`, *Cardinality* - `ONE_TO_MANY`.



https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/insurance/InsuranceCompany.java[InsuranceCompany.java] - `InsuranceCompany` 实体包含一个一对多的 `InsuranceMembership` 实例组合。

.InsuranceCompany.java
[source, java]
----
@Composition
@OnDelete(DeletePolicy.CASCADE)
@OneToMany(mappedBy = "insuranceCompany")
protected List<InsuranceMembership> memberships;
----


https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/insurance/InsuranceMembership.java[InsuranceMembership.java] - 从而,  `InsuranceMembership` 实体包含两个多对一引用： `pet` 和 `insuranceCompany`.

.InsuranceMembership.java
[source, java]
----
@NotNull
@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "PET_ID")
protected Pet pet;

@NotNull
@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "INSURANCE_COMPANY_ID")
protected InsuranceCompany insuranceCompany;

@Temporal(TemporalType.DATE)
@NotNull
@Column(name = "VALID_FROM", nullable = false)
protected Date validFrom;

@Temporal(TemporalType.DATE)
@Column(name = "VALID_UNTIL")
protected Date validUntil;
----

* https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/global/src/com/haulmont/sample/petclinic/views.xml[views.xml] - 宠物编辑界面使用的 `pet-with-owner-and-type-and-memberships` 视图含有 `insuranceMemberships` 组合属性（引用 `InsuranceMembership` 关联实体），其中包含 `insuranceCompany` 和额外的有效期信息：`validFrom` 和 `validUntil` 。


+
`insuranceCompany-with-memberships` 视图遵循相同的逻辑：含有 `memberships` 组合属性（引用 `InsuranceMembership` 关联实体 ）， 其中包含了 `pet` 和额外的有效期信息： `validFrom` 和 `validUntil` 。


宠物编辑界面的 XML 描述中为 `Pet` 实例定义了一个数据容器，为它的 `insuranceCompany` （通过  `InsuranceMembership` 关系） 实例定义了一个嵌套数据容器。 界面上有一个用于显示投保关系的表格和一个可以跳过`InsuranceMembership` 编辑器直接选择 `InsuranceCompany` 的自定义操作。

最终 ，编辑 `InsuranceMembership` 实例的过程如下:

`Pet` 编辑界面显示一个保险公司列表和投保关系的有效期范围。


用户可以点击  *Add Insurance*  按钮， `InsuranceCompany` 的查找界面会被打开，用户可以选择一个已有的保险公司或者创建一个新的保险公司。当前用户选择了一个保险公司后，一个新的 `InsuranceMembership` 实例会被 https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/pet/pet/PetEdit.java#L57[创建]，新的实例使用了默认的有效期范围。这个实例不会被直接保存到数据库， 只是添加到了 `Pet` 编辑界面的 `insurancesMembershipsDc` 数据容器。

TIP:  当从宠物编辑界面通过上述方式进行了多对多关系的创建后，会通过  https://github.com/cuba-guides/cuba-petclinic-data-model-many-to-many/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/insurance/insurancecompany/InsuranceCompanyEdit.java[`InsuranceCompany` 编辑界面] 创建或更新一个  `InsuranceCompany` 实例。 保险公司实例的创建或更新是完全独立地被保存到数据库。用户可以创建一个新的保险公司同时删除一个已有的保险公司，对保险公司的所有修改都是在一个独立的事务中保存到数据库。


当用户点击宠物编辑界面上的 OK 按钮，修改后的 `Pet` 实例和所有修改的 `InsuranceMembership`  实例会提交到中间件的  `DataManager.commit()` 方法并在同一个事务中保存到数据库。


== 总结

在这个数据建模指南中我们演示了多对多关系。多对多关系对于关系的两边都需要链接另一边的多个条目时非常有用，上述的 `Vet` <--> `Specialty`  用例即是这种情况。如果业务场景需要，可以通过添加额外的信息对这关系进行增强，上面展示的为 `InsuranceMembership` 实体添加 `validFrom` & `validUntil` 属性的用例即是这种场景。
