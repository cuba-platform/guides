---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-data-model-composition
permalink: data-modelling-composition
---
= Data Modelling: Composition
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Data Modelling: Composition
:page-excerpt: Data modelling guide: How entity inheritance can be used in a CUBA application
:page-root: ../../../
:project_id: cuba-petclinic-data-model-composition
:java_version: 1.8
:cuba_version: 7.0


== What Will be Build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA petclinic] example to show the mechanism to define entity inheritance. In particular, the following use cases will be covered:

* `Pet` entity becomes a the superclass for all Pet types
* `Cat`, `Bird` and `Rat` will be created as concrete Pet type entities
* The user has the choice between different Pet types at creation time of the Pet. The system will show the corresponding editor accordingly so that the user can also enter the type specific information.


* One level: Owner <>--> Address
* Two levels: Pet <>--> Health Records <>--> Attachment
* Three levels: Owner --> Pet --> Visit --> Note

=== Final Application

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-entity-inheritance/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-entity-inheritance/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]

== Composition vs. Association

CUBA platform supports two types of relationship between entities: association and composition. They are called ASSOCIATION and COMPOSITION respectively in the CUBA Studio interface. Association is a relationship between the objects that can exist separately from each other. Composition, on the other hand, is used for "master-detail" relations, when the detail instances can exist only as part of the master.

In the Petclinic example a case of an `Owner` and its `Addresses` may be considered an example of composition: an `Address` that does not belong to any `Owner` does not make sense.


Typically, the entities belonging to a composition are edited together since it is more natural. A user opens the `Owner` editing screen and sees the list of `addresses`, so the user can create and edit them, but all changes both for the `Owner` and the `Address` are saved to the database together in one transaction, and only after the user confirms saving of the master entity (the `Owner`).

===== One-to-Many: One Level of Nesting

A one-to-many composition using the `Owner` and the `Address` entities as an example:

image::data-model-composition/composition_domain_model_one_level.png[align="center"]

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/owner/Address.java[Address.java] - the `Address` entity contains a mandatory link to the `Owner`.
+

NOTE: In the Studio entity designer, the `airport` attribute: *Attribute type* - ASSOCIATION, *Cardinality* - MANY_TO_ONE, *Mandatory* - on.

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/airports/Airport.java[Airport.java] - the `Airport` entity contains a one-to-many collection of terminals. The corresponding field is annotated with <<composition_annotation,@Composition>> in order to implement composition, and <<onDelete_annotation,@OnDelete>> for cascaded soft delete.
+
In the Studio entity designer, set for the `terminals` attribute: *Attribute type* - COMPOSITION, *Cardinality* - ONE_TO_MANY, *On delete* - CASCADE.

* {proj_model}/blob/master/modules/global/src/com/company/sample/views.xml[views.xml] - the `airport-terminals` <<views,view>> of the airport editing screen contains the `terminals` collection attribute. We are using the `_local` view for this attribute, because the `airport` attribute of the `Terminal` entity is set only at the creation of a new `Terminal` instance and never changes after that, so we do not need to load it.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-edit.xml[airport-edit.xml] - the XML descriptor of the airport editor defines a datasource for the `Airport` instance and a nested one for its terminals. It also contains a table displaying terminals.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports/terminal/terminal-edit.xml[terminal-edit.xml] - a standard editor for the `Terminal` entity.

As a result, editing of an airport instance works as follows:

* The airport edit screen shows a list of terminals.

* A user can pick a terminal and open its editor. When *OK* is clicked in the terminal editor, the updated instance of the terminal is not saved to the database, but to the `terminalsDs` datasource of the airport editor.

* The user can create new terminals and delete existing ones. All changes will be saved to the `terminalsDs` datasource.

* When a user clicks *OK* in the airport edit screen, the updated `Airport` instance together with all the updated `Terminal` instances is submitted to the <<dataManager,DataManager>>.commit() method on the middleware and saved to the database within a single transaction.

== Summary
