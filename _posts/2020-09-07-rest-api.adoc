---
compatible_cuba_versions: 7.1+
compatible_java_versions: 8+
project_id: cuba-petclinic-rest-apis
permalink: rest-apis
---
= REST APIs for CUBA applications
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: REST APIs for CUBA applications
:page-excerpt: In this guide you will learn how to create REST APIs for a CUBA application. We will explore mechanisms to create different types of APIs by adding Owner registration to the Petclinic as well as allow third-party applications to control the visit management.
:page-root: ../../../
:project_id: cuba-petclinic-rest-apis
:java_version: 8
:cuba_version: 7.1
:page-icone: https://www.cuba-platform.com/guides/images/application-components/guide_icone.svg

In this guide you will learn how to create REST APIs for a CUBA application. We will explore mechanisms to create different types of APIs by adding Owner registration to the Petclinic as well as allow third-party applications to control the visit management.

== What we are going to build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA Petclinic] example so that Owners can self-register online before the Visit. In the second example we will allow a third party tablet application to do the visit management via a custom secured REST API.

include::includes/guide_requirements.adoc[]

== Overview

Providing an API for an application is oftentimes a good way to foster machine to machine communication. CUBA supports various forms of API technologies through its strong foundation in form of the Spring Framework. Spring has native support for creating REST and SOAP-Webservice based APIs. Also, newer technology approaches like GraphQL are possible with the help of the wider Java ecosystem.

Additionally, CUBA offers dedicated support for REST APIs via a generic API, which allows to manage the complete application entity model through automatically available endpoints.

In this guide we will focus on creating multiple REST based HTTP APIs in order to allow other applications interact with the CUBA Petclinic.
During the examples we will work with both the generic API and custom HTTP endpoints based on the use-case at hand.

== What is a REST API

Before exploring the details of the CUBA implementation of proving an API, let's quickly talk about what a REST API looks like and what the concepts behind it are.

A REST API is an HTTP based API (HTTP being the protocol, that is the underpinning of a big part of the Internet) with some specific usage of it. REST in particular has a couple of building blocks, that we will use throughout this guide.


Generally speaking an API is a mechanism to let different systems communicate with each other and exchange data. The API then is the defined interaction mechanism in which those two applications can communicate. To make it more concrete, take the analogy of a restaurant:

TIP: The menu that the restaurant offers is the API. Once you order a piece from the menu, you are doing an API call with a more or less structured interaction format ("I take number 25", "Pizza is out, sorry!", "Something to drink?"). The response of that API call is the food which is delivered from the kitchen.

Let's unfold the concepts which REST defines as one particular style of an API:

=== Resources

A Resource is something that you can think of like an abstraction on the concept of any kind of information. Examples of a resource can be an image, a document or a dish in a menu. In can also be a Pet, but not the actual Pet. It would be rather a virtual representation of it in the Petclinic application. Resources are identified by something called a Resource Identifier. In its concrete form a resource identifier is something like a URL: `https://petclinic.cuba-platform.com/pets/123` to identify the Resource: The pet with the Identification Number: 123.

=== Resource Verbs

Verbs on Resources represent the "operations" that you can perform on a particular resource. In REST those Verbs should form a uniform interface (abstract definition). In the concrete in HTTP there are a couple of Verbs, that can be used in order to interact with a resource:

* `GET https://petclinic.cuba-platform.com/pets/123`: fetches information about the Pet with the Identification Number 123
* `PUT https://petclinic.cuba-platform.com/pets/123`: updates information about the Pet with the Identification Number 123
* `POST https://petclinic.cuba-platform.com/pets`: adds a new Pet to the list of existing Pets

There are a handful of verbs defined in HTTP that can be used. All of them have a particular meaning, although their interpretation and usage
is oftentimes up to the provider of the API.

Generally the Verbs have different characteristics / guarantees associated to it. E.g. the verb `GET` normally is used for loading data. By the HTTP specification a `GET` operation is _idempotent_ and _safe_. Roughly speaking this means that the operation in the API should not have side effects. Also, applying the same operation twice should not lead to a different outcome. Loading information about a Pet is generally possible to do multiple times without having a side effect. Therefore, using the `GET` verb for this operation is matching the guarantees the `GET` verb offers.

Registering a Pet on the other hand twice would lead to having two Pets stored in the application. Therefore, this operation is not side-effect free. For those kinds of operations the `POST` verb would be a better fit, as this verb does not give guarantees about side-effect freeness.

There are several verbs defined in HTTP. The primary ones are `GET`, `POST`, `PUT`, `DELETE`, `PATCH`.

== Requests and Responses

Requests and responses conceptually are not described by REST, but they are a very integral part of an HTTP based API. Requests and responses are the actual interactions that happen between the client and the server of an HTTP interaction. A request is the initial message from the client to the server. The response on the other hand is the resulting message from the server to the client. Both interactions normally contain two parts: the message payload and the message metadata.

Here is an example of how an HTTP request & response interaction looks like:


.Example HTTP Request for creating a Visit
[source,http]
----
POST http://petclinic.cuba-platform.com/rest/api/visits //<1>
Authorization: Bearer 71dbb8a8-2a41-45e7-a73b-16a96c433651
Content-Type: application/json // <2>

{ // <3>
  "petIdentificationNumber": "025",
  "visitStart": "2020-04-05T08:00:00",
  "visitEnd": "2020-04-05T10:00:00",
  "type": "REGULAR_CHECKUP",
  "description": "This is a regular checkup for Pikachu"
}
----
<1> the Verb + Resource identifier to express what operation should be performed
<2> the `Content-Type` describes to the server on how to interpret the message payload
<3> the payload / body of the request containing the business relevant information

After the server has received the HTTP request, it would e.g. produce the following response:

.Corresponding HTTP Response indicating a Visit was created
[source,http]
----
HTTP/1.1 200 // <1>
Content-Type: application/json

{ // <2>
  "id": "4e3bde19-c0ec-7cd0-654a-577ba32dcc7f"
}
----
<1> `200` indicates the response code to categorize the outcome of interaction
<2> the response message (body) contains the actual business relevant information (visit identifier in this case)


The message payload of an API interaction oftentimes uses the JSON format, as seen above. That being said, it is possible to exchange different message formats through HTTP as well, like `XML`, or `www-url-formencoded`. Also, binary formats are possible (to transfer PDF documents / images).

With this general information, we can now point our focus on how to convert those abstract descriptions into real working APIs in a CUBA application.

== How to create an HTTP Controller

In the next section, we will take a look into the concrete usage of the HTTP inside a CUBA application. CUBA is based on Spring, which offers dedicated support for providing HTTP APIs. In particular Spring MVC is responsible for offering that functionality.

In order to create a HTTP endpoint it is necessary to create a Java class and annotate it with `@RestController`. In order to fulfil the implementation of the API operation `GET https://petclinic.cuba-platform.com/pets/123`, a method needs to be annotated with `@GetMapping` in order to connect it to a particular endpoint.

Here you find an example of such a REST Controller in Spring MVC:

.FetchPetController.java
[source,java]
----
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController // <1>
public class FetchPetController {

    @GetMapping("/pets/{petId}") // <2>
    public ResponseEntity<Pet> fetchPet(
        @PathVariable("petId") String petId // <3>
    ) {

        final Optional<Pet> possiblePet = dataManager.load(Pet.class)
            .query("e.identificationNumber = ?1", petId)
            .optional();

        if (!possiblePet.isPresent()) {
            return ResponseEntity.notFound().build();
        }

        return ResponseEntity.ok( // <4>
            possiblePet.get()
        );
    }
}
----
<1> Registering the class as a HTTP / REST controller
<2> the `fetchPet` method links to the endpoint `GET /pets/{petId}` via the `@GetMapping` annotation
<3> the `petId` part of the URL is dynamic and gets passed into the method as a parameter
<4> ResponseEntity takes care of returning the correct HTTP status code and HTTP response body

For the different HTTP verbs Spring MVC provides the corresponding Annotations, as we will see in later code listings.

One part of the HTTP message metadata is the response code. Those codes are used to indicate the client different outcomes of the operation. The response code `200 - OK` is indicating a successful operation, whereas `404 - Not Found` tells the client that the resource that was requested is not available. There are several response codes that can be used to very precisely describe the outcome of an operation.

The `ResponseEntity` is responsible for controlling what HTTP response is returned to the client. It on the one hand describes the metadata like the response code, but is also used to define the response body. In the example above a Pet object is treated as the response body. Spring MVC takes care of converting the Pet object into a JSON format and returns it to the HTTP client.

== REST API for Petclinic

In this section we will look into the CUBA Petclinic application and go through two examples: public owner registration as well as Visit management via API.

=== Request examples in Petclinic Example

All example requests for testing out the solution can be found in the https://github.com/cuba-guides/{project_id}/blob/master/requests[requests] directory in the example project. This directory contains multiple example requests that can be used to interact with the running CUBA application. It allows to interactively use the API and see the actual HTTP requests and responses.

image::rest-api/http-request-example.png[Example HTTP request, link="images/rest-api/http-request-example.png"]


=== Public Registration Endpoint for creating Owners through a Website (Form Submit / JSON request)

* Custom Spring MVC Endpoint
* Custom JSON POJO


=== Secured API for managing Visits in third party application

The second example is a new application called `PetTreat` will be used at the Petclinic by Vets and Nurses on their tablet. `PetTreat` should support the employees performing the treatments of the pets. In order to achieve this, the tablet application needs to communicate with the `CUBA Petclinic` application. Furthermore, the data that is handled in `PetTreat` should be updated accordingly in the `CUBA Petclinic` application to be accessible to all employees.

After an initial exploration of the required functionality, the following data interactions with the Petclinic were identified:

* Lookup data of a Pet
* Create a Visit for a Pet
* See information about an already existing Visit
* Start & end a Treatment during a Visit

As these kinds of information and operations are very sensitive, it is required to only allow the corresponding Vets and Nurses to interact with the `CUBA Petclinic` system through `PetTreat`. As the information should be available immediately for all other employees at the Petclinic after it was entered in PetTreat, an API in the Petclinic will be used for the interactions between `PetTreat` and CUBA Petclinic.

CUBA offers solutions for those requirements through the above mentioned Spring MVC APIs as well through the generic REST API addon. In this example we will look into both solutions and compare the implementation of them.

In order to support the authorization requirements, we will start by looking into CUBA OAuth2 implementation, which is a mechanism to authenticate users through the API.

==== CUBA OAuth2 API Authentication

OAuth2 is an internet standard for providing an authentication mechanism for an API usage.

==== Variant 1: using REST addon for generic exposure of Visit entity

* Using Visit Entity directly in Entity Endpoint
* Using Visit Management Service for higher level API abstraction

==== Variant 2: Custom higher level API operations
* Create custom Request Objects for Visit Management (CreateVisitRequest, FinishTreatmentRequest, GetTreatmentStatusRequest)

==== Pros & Cons of using generic vs. custom API

Custom API:
* Ability to control HTTP interaction (custom Status Code, error responses etc.)
* Decoupling between entity model and API model when using custom REST API
* Non CRUD possibilities when using custom REST API

Generic API:
* Speed of Development
* additional functionality (search, views, queries, pagination, Swagger etc.)
* Service Exposure for non-CRUD operations


== Further Information

* https://doc.cuba-platform.com/manual-latest/extension.html[CUBA docs: Functionality Extensions]
* https://doc.cuba-platform.com/manual-latest/app_components.html[CUBA docs: Application components]
