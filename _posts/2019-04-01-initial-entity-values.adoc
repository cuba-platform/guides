---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-initial-entity-values
permalink: initial-entity-values
---
= Initial Entity Values
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Initial Values for Entity Instances
:page-excerpt: Data modeling guide: How entity inheritance can be used in a CUBA application
:page-root: ../../../
:project_id: cuba-petclinic-initial-entity-values
:java_version: 1.8
:cuba_version: 7.0

This guide demonstrates different options on how initial values can be set for an entity.

In the petclinic example there are several screens that can


== What Will be Build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA petclinic] example to show the mechanism to define entity inheritance. In particular, the following use cases will be covered:

* `Pet` entity becomes a superclass for all Pet types
* `Cat`, `Bird` and `Rat` will be created as concrete Pet type entities
* A user has a choice between different Pet types at creation time of a Pet. The system will show the corresponding editor accordingly so that the user will be also able to enter the type specific information.


=== Final Application

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-entity-inheritance/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-entity-inheritance/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]


== Entity Fields Initialization

Simple attributes (`Boolean`, `Integer` etc.) and enumerations can be initialized in the declaration of the corresponding field of an entity class. In the Petclinic example, the Visit entity has an attribute `paid` which is a boolean flag to indicate, if a visit has been payed already. This value should by default be `FALSE`. The default value can be set directly at the field definition.

.Visit.java
[source, java]
----
public class Visit extends StandardEntity {

    // ...

    @Column(name = "PAID")
    protected Boolean paid = Boolean.FALSE;

}
----

Additionally, a specific initialization method with a `@PostConstruct` annotation can be created in the entity class. In this case, any global infrastructure interfaces as well as managed beans can be invoked during initialization. One example of this post-construct initialization can be seen in the `Visit` entity:

.Visit.java
[source, java]
----
public class Visit extends StandardEntity {

    @Temporal(TemporalType.DATE)
    @NotNull
    @Column(name = "VISIT_DATE", nullable = false)
    protected Date visitDate;

    // ...

    @PostConstruct // <1>
    private void initVisitDate() {
        if (visitDate == null) { // <2>
            setVisitDate(today());
        }
    }

    private Date today() {
        TimeSource timeSource = AppBeans.get(TimeSource.class); // <3>
        return timeSource.currentTimestamp();
    }
}
----
<1> `@PostConstruct` triggers this method after creation of an instance of this class. It is called when manually creating an instance via `metadata.create(Visit.class)` as well as instance creation by the framework (e.g. when a instance is created during the data loading process from the database
<2> When the instance is created from a database record, a `visitDate` might have been initialized with the correct value. Therefore it is required to check if the attribute is null
<3> Managed beans can be referenced via `AppBeans.get()`

== UI Layer Initialization

On the UI layer there are two main ways to initialize an entity during screen creation. The first one is internal within the screen controller, that should show the newly created entity. The second one is external, where the entity and its attributes are defined by the screen controller creating the destination screen.

=== Internal Initialization via InitEntityEvent

The alternative to the external entity initialization is to do the entity initialization within the destination screen controller itself. In this case the CUBA platform UI events can be leveraged. In particular for `StandardEditor` screens there is a particular UI event that is desinged exactly for this purpose: the `InitEntityEvent`.

In the petclinic example this internal initialization is used to set the paid status of the regular checkup visit instance to paid.

.RegularCheckup.java
[source,java]
----
public class RegularCheckup extends StandardEditor<Visit> {

    @Subscribe
    protected void initRegularCheckupVisit(InitEntityEvent<Visit> event) { // <1>
        Visit visit = event.getEntity();

        visit.setPaid(false); // <2>
    }

}
----
<1> the `initRegularCheckupVisit` method subscribes to the `InitEntityEvent` of the newly created `Visit` instance
<2> `event.getEntity()` returns the Visit instance that can be changed during screen initialization

The upside of this kind of initialization is that is very easy to achieve and does require very little overall code changes. The downside is that since it is scoped within the destination screen it is not so easy to react to external parameters that get passed into the screen. Therefore it is a very good fit when particular attributes should be initialized that are not dynamic.

=== External Initialization via Screen Builders

On the frontend layer with CUBA 7 the `ScreenBuilders` API was introduced. It allows to programmatically create and open screens with various options to configure.

One of this options is the possibility to define an initializer method, that gets executed before opening the screen, where it is possible for an Editor screen to change attributes of the entity that will be displayed.

In the Petclinic example there is a screen that creates a particular visit instance. This visit is a "regular checkup". As this checkup is always the same in the sense that it requires some checklist kind of description. Furthermore it always paid upfront. Since it is a burden for the users to create those special kinds of visits over and over again, a screen was implemented that comes with sensible defaults for this kind of use-case.

.VisitBrowse.java
[source,java]
----

@Inject
private ScreenBuilders screenBuilders;

@Inject
private MessageBundle messageBundle;

@Inject
private GroupTable<Visit> visitsTable;

// ...


@Subscribe("visitsTable.createRegularCheckup")
public void createForPet(Action.ActionPerformedEvent event) {
    screenBuilders.lookup(Pet.class, this)
            .withSelectHandler(pets -> {
                createVisitForPet(pets.iterator().next());
            })
            .withLaunchMode(OpenMode.DIALOG)
            .build()
            .show();
}

private void createVisitForPet(Pet pet) {
    screenBuilders.editor(visitsTable) // <1>
        .newEntity() // <2>
        .withInitializer(visit -> { // <3>
            visit.setPaid(true);
            visit.setDescription(regularCheckupDescriptionContent(pet));
            visit.setPet(pet);
        })
        .withScreenClass(RegularCheckup.class)
        .withLaunchMode(OpenMode.DIALOG)
        .build()
        .show();
}
----
<1> A `EditorBuilder` will be created using the `screenBuilders` bean
<2> the mode of the `EditorBuilder` is set to create mode
<3> The `withInitializer` method takes a `Consumer<Visit>` that gets a new visit instance as a parameter, which then can be adjusted accordingly

With the ScreenBuilder API and the external initialization it is possible to create default values much more dynamically. As it is shown in the above example, in the first step the pet is selected. Based on this selection a description gets generated and put into the to be created visit entity.

The downside of this approach is that it is a little less invasive in terms of source code. It is also not possible to reuse the default actions (create / edit) as is without further modifications.

As it is shown in this example, it is also possible to combine the two approaches and use them in the different use-cases. The pet and the description of the visit are initialized externally, but the paid status is internally set.

The corresponding UI screens look like this:

image::initial-entity-values/regular-checkup-1-select-pet.png[Step 1: Pet selection, link="initial-entity-values/regular-checkup-1-select-pet.png"]

image::initial-entity-values/regular-checkup-2-prefilled-visit.png[Step 2: Prefilled visit screen, link="initial-entity-values/regular-checkup-2-prefilled-visit.png"]


== Pre-Persist Field initialization

TIP: In this section there should be the case discussed where an attribute is set directly before persisting and it is calculated based on other fields that have been chosen by the user during creation phase. This is another form of initialization, and I would argue that it makes sense to talk about that. Perhaps it is also possible to differentiate between the cases where we have more calculated fields that should be visible to the user at creation time and others that should only be set while persisting and only seing them after the fact.

== Summary

In this guide different options on how to set initial values for entity instances were shown. It is possible to define certain initial values directly within the Entity class via direct attribute allocation or the `@PostConstruct` annotation.

This kind of initialization will be executed in all scenarios and is therefore oftentimes the preferred way of doing attribute initialization. But sometimes it is required to have more information on the context of the execution, e.g. prior selections of the user on the UI.

Therefore it is also possible to initialize attributes on the UI layer. There are multiple ways to do it as shown above. It allows the developer to react more flexible on the UI selection etc.

The main difference is, that these kinds of initializations are only applied when the user uses this particular UI to interact with the system. Oftentimes there are other use-cases, like the REST API, Bulk Editor functionality, data import scenarios etc. If it is required to initialize an attribute for all those use-cases the Entity Field initialization should be preferred.

== Further Information

* https://doc.cuba-platform.com/manual-{cuba_version}/opening_screens.html#screenBuilders[Screen Builders reference documentation]
