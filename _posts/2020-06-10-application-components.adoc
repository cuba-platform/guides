---
compatible_cuba_versions: 7.1+
compatible_java_versions: 8+
project_id: cuba-petclinic-product-line-platform
permalink: product-customizations-with-app-components
---
= Product Customizations with Application Components
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Product Customizations with Application Components
:page-excerpt:In this guide you will learn how customer-specific solutions can be created based on a standard product. We will leverage the capabilities of CUBAs application components to modularize the overall application.
:page-root: ../../../
:project_id: cuba-petclinic-product-line-platform
:java_version: 8
:cuba_version: 7.1
:page-icone: images/unit-testing/guide_icone.svg

In this guide you will learn how customer-specific solutions can be created based on a standard product. We will leverage the capabilities of CUBAs application components to modularize the overall application.

== What we are going to build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA Petclinic] example to show how two customer-specific extensions `Kanto-Petclinic` and `Alabastia-Petclinic` can be created and how specific extensions are created:

* convert the Petclinic project into a CUBA application component
* create two CUBA applications: `Kanto-Petclinic` and `Alabastia-Petclinic` that use the CUBA Petclinic as a basis

=== Kanto-Petclinic

The Kanto Petclinic extends the original Project with the following customer specific behavior:

* additional attribute `previousIllnesses` to the Visit Entity
* allow users to create a Visit for today from the Pet Browse screen

=== Alabastia-Petclinic

The Alabastia Petclinic extends the original Project with the following customer specific behavior:

* give users the ability to assign Treatment Rooms to Visits
* automatically pre-select the Assigned Nurse based on the current user when creating a new Visit
* automatically pre-select the Nurses Treatment Room for a new Visit


include::includes/guide_requirements.adoc[]

== Overview

Application components in CUBA can be used to create reusable components of functionality that can be leveraged in other CUBA applications. Depending on how much functionality the application component contains, it can have the form of a small addon, that enriches your application with a particular aspect.

But application components can also be used to represent a complete application. In this case, the application component contains all the entities, screens and business logic that the standard application consists of. Then the actual application just uses the application component and only puts very slight adjustments on it.

This second scenario is what we will be covering in this guide in particular. In the example we will convert the Petclinic application into an application component. Then we will create two applications, that use the Petclinic and adjust it to their customer-specific needs.

With this approach we can incorporate requirements from customers, that would like the standard product (Petclinic) to be adjusted in order to use it. Application components give us a compile-time extension mechanism for this problem.


=== Different Extension Mechanisms

Before we dive into the concrete example of the Petclinic, let's explore the differences between compile-time and runtime extensions. Depending on the required capabilities, deployment- and distribution mechanisms of the product one or the other might be more suitable.

==== Runtime Extensions: Plugins, Scripting & Configuration

The first extension mechanism of a CUBA application is a runtime extension. The main characteristic of that extension is, that during the build process one application artifact like a `war` binary has been created. This binary is always the same and distributed to all customers. The extension part of the application does not change the original binary e.g. by replacing certain classes.

Instead, the extensions are added at runtime / deployment time of the application. This can be done in various forms. One example is a plugin architecture. In this case it would be additional jar files, which contain the plugins for the application. Those jar files are placed into the application server. Oftentimes it is required to restart the application to pick up those plugins.

Such a jar file plugin can contain source code. Normally it is used for implementing certain interfaces that are defined within the main application, in order to fulfil / replace a particular functionality.

The next step, which is less powerful is Scripting. In CUBA there are several mechanisms / examples built-in for scripting in place. Scripting allows to programmatically define particular pre-defined areas of the functionality in the application. One example of that inside CUBA itself is the Constraint definition within the security groups administration. It is possible to define a groovy script, which will determine if a particular user has access to a particular resource like an entity record.

Oftentimes scripting is combined with configuration. Taking the Constraint definition once again: the groovy script is just one part of the dynamic configuration. It actually belongs to a bigger "Constraint configuration", which includes a link to an Entity, a type of operation etc.

Configuration also allows certain extension capabilities. But those extension points are very limited in terms of the overall application and they also need to be defined within the application itself.

==== Compile-Time Extension: Application Component

The second extension mechanism of a product is a compile-time extension. This type of extensions happen during the production process of the software. It may happen at development time through customer specific extensions / adjustments of the standard product. Alternatively it can also happen at the time the binary is created e.g. by adding certain additional `jar` files into the binary.

In this case, everything is still possible to change, because it is very early in the software production process. Additional entities can be created, business logic can be overridden and customer-specific UIs can be created.


== Petclinic as a Product Line

Picking up the Petlinic example from above, what we will do in this guide is to make the Petclinic product not a standalone software anymore, but rather a Product Line. The base product is the Petclinic example as we know it. Additionally there are extensions made for particular customer types or even a particular customerss.

Those extensions are itself CUBA applications (`Kanto-Petclinic` and `Alabastia-Petclinic`) that uses the Petclinic base product as an application component. With that we will leverage the compile-time extension mechanism for a CUBA application.

Additionally, we will go through an example of a runtime extension of the petclinic, which not bound to the originally delivered binary, but rather acts as an addon to the application.

=== Making the Petclinic Project an Application Component

In order to leverage the Petclinic project as a product line, it is required to understand what makes up a CUBA application component and where it is different over a regular CUBA application. In fact, the difference it is not very much - only one particular file called `app-component.xml`. This application component descriptor file marks a CUBA application additionally to be used as an application component. This means - it can be used by other CUBA applications.

Besides that, nothing really changed. The application component can still be used as a regular CUBA application. It can be started in CUBA Studio, business logic can be created, UIs can be generated etc.

Used by other CUBA applications in this case means not only that the functionality of the application component shows up in the resulting application. Also it is possible to interact with any part of the application component from inside the target application. Entities (like the `Pet` entity) can be referenced, Spring beans can be overridden, UI screens can be extended or replaced etc.

Let's look into the `app-component.xml` of the Petclinic example:

.app-component.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<app-component xmlns="http://schemas.haulmont.com/cuba/app-component.xsd"
  dependsOn="com.haulmont.cuba, com.haulmont.addon.helium">

  <module name="global" blocks="*">
    <artifact name="petclinic-global" appJar="true"/>

    <property name="cuba.persistenceConfig" value="+com/haulmont/sample/petclinic/persistence.xml"/>
    <property name="cuba.metadataConfig" value="+com/haulmont/sample/petclinic/metadata.xml"/>
    <property name="cuba.viewsConfig" value="+com/haulmont/sample/petclinic/views.xml"/>
  </module>
  <module name="core" dependsOn="global" blocks="core">
    <artifact name="petclinic-core" appJar="true"/>
    <property name="cuba.mainMessagePack" value="+com.haulmont.sample.petclinic.core"/>
    <!-- ... -->
  </module>
  <!-- ... -->
</app-component>
----

This file contains a formal description of the structure of the application component. It exposes a couple of `module` elements. Those modules can declare `artifact` elements as well as `property` elements that should be exposed for this application component.

CUBA mainly uses this information for configuring the right application properties (and values) as well as downloading the correct dependencies.
Normally this file does not need to be changed manually at all, because it only contains static information about the structure of the application component.

TIP: Through CUBA Studio it is possible to generate the application component descriptor via the Menu: `CUBA > Advanced > App Component Descriptor`.


=== Using the Petclinic Application Component in a CUBA Application

After making the Petclinic project an application component, it is necessary to install it to a maven repository, so that the dependency mechanisms from CUBA (in particular from Gradle) can download the application component in the target application.

For installing there is a dedicated gradle task, that has to be performed in the application component project: `./gradlew install` (the equivalent Menu entry in CUBA Studio is `CUBA > Advanced > Install App Component`).

With that task, the application component is build and put into the local maven repository of the computer, in particular in the `.m2` directory within the users home directory:

image::application-components/local-maven-repository.png[]

After installing the application component, it can be used in the target application. One prerequisite for using an application component from the local maven repository, is inside of the `repositories` block of the `build.gradle` file the maven local repository needs to be mentioned:

.build.gradle
[source,groovy]
----
repositories {
    mavenLocal()
    //...
}
----
In order to use it, the dependency can be installed through CUBA Studio. Via `CUBA > Marketplace...` an application component can be found. In this case, the petclinic application component is not in the public CUBA Marketplace, but rather in our local computer. Therefore, it does not appear in the list. On the top right, there is a button called `Install add-on manually`, which allows to enter the coordinates of the application component: `com.haulmont.sample.petclinic:petclinic-global:2.0.0`.

TIP: When using a development approach within a team the normal way of handling such a dependency is to use a dedicated maven repository like `Nexus`, `Artifactory` or `Github Packages` where the application component binaries are stored. In this case the application component does not need to be installed locally on everyone's machine.

With those preconditions in place, the target application is ready to start. It will contain all the entities and screens from the application component as well as its own.

== Petclinic Extensions

As described in the beginning, we will do certain extensions to the different customers and their dedicated applications.

=== Kanto-Petclinic

We will start of with the Kanto-Petclinic. This project only needs slight adjustments to the Petclinic core. There is one additional information to store for a Visit, which described previous illnesses. Additionally, in the Kanto-Petlinic there are a lot of emergency visits. This requires the nurses to oftentimes create Visits of a particular type for today. In order to support this use-case, there should be a shortcut way of creating this kind of visit.

==== Extending the Visit Entity

In order to achieve the first requirement of storing previous illnesses to the Visit, the `Visit` entity has to be extend. CUBA allows to extend screens from application components or the framework itself via the `@Extends` annotation on the JPA entity. For the Kanto-Petclinic adding attribute looks like this:


.KantoVisit.java
[source,java]
----
@Extends(Visit.class)
@Entity(name = "kantopetclinic_KantoVisit")
@DiscriminatorValue("KantoVisit")
public class KantoVisit extends Visit {

    @Column(name = "PREVIOUS_ILLNESSES", length = 4000)
    private String previousIllnesses;

    public String getPreviousIllnesses() {
        return previousIllnesses;
    }

    public void setPreviousIllnesses(String previousIllnesses) {
        this.previousIllnesses = previousIllnesses;
    }
}
----

The `@Extends` annotation replaces all occurences of the `Visit` entity with its new extension  `KantoVisit`. As the subclass can still be treated as a `Visit` this also means, all existing logic / screens that is inside the application component will continue to work.

After that addition, CUBA Studio will generate the corresponding database update scripts. This will alter the original table instead of defining a new one.

The second part of that feature requirement is that the attribute `previousIllnesses` can also be managed in the UI. For this, we will extend the existing UI screen of a Visit. CUBA Studio guides you through the process of extending a screen via `Screens > New > Screen > Extend an existing Screen`. The field should only be added to the Entity editor screen, so extending `VisitEdit` is sufficient.

In order to add a field to an existing `form` component, the "delta" XML (containing all the new attributes) has to be put in the XML screen descriptor of the new extension screen. Here you will see how it looks when extending the Visit Editor screen to add the `previousIllnesses` field to it:


.rocky-mount-visit-edit.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd"
  messagesPack="com.rockymount.petclinic.web.screens.visit"
  xmlns:ext="http://schemas.haulmont.com/cuba/window-ext.xsd"
  extends="com/haulmont/sample/petclinic/web/screens/visit/visit-edit.xml"> // <1>
  <layout>
    <form id="fieldGroup">
      <column id="column1">
        <textArea
          id="previousIllnessesField"
          rows="5"
          property="previousIllnesses"
          colspan="2"
          width="100%"/>
      </column>
    </form>
  </layout>
</window>
----
<1> the extends attribute declares on which screen this screen extension is based upon

In this case, the text area for the new field is appended at the bottom of the form component with the ID `fieldGroup`. It is also possible to further specify the placement of the component inside its parent component via the `ext` namespace.

==== Create Visits for Today from Pet Browse

The second extension that the Kanto-Petclinic requests is to have a shortcut on creating a Visit for today.

This can be achieved by creating another screen extension to the Pet Browse screen. The extension adds one action to the Pet Table called `Create Visit`. The extension of the screen in the XML screen descriptor looks like this:


.rocky-mount-pet-browse.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd"
  messagesPack="com.rockymount.petclinic.web.screens.pet"
  extends="com/haulmont/sample/petclinic/web/pet/pet/pet-browse.xml">
  <facets>
    <inputDialog // <1>
      id="createVisitForPetDialog"
      defaultActions="OK_CANCEL"
      caption="msg://createVisitForPetCaption"
      onAction="petTable.createVisit"
    >
      <parameters>
        <enumParameter
          id="visitType"
          enumClass="com.haulmont.sample.petclinic.entity.visit.VisitType"
          caption="msg://com.rockymount.petclinic.web.screens.pet/visitType"
        />
      </parameters>
    </inputDialog>
  </facets>
  <layout>
    <groupTable id="petsTable"> // <2>
      <actions>
        <action id="createVisit"
          trackSelection="true"
          caption="msg://createVisit"
          icon="USER_MD"
        />
      </actions>
      <buttonsPanel id="buttonsPanel">
        <button id="createVisitBtn" action="petsTable.createVisit"/> // <3>
      </buttonsPanel>
    </groupTable>
  </layout>
</window>
----
<1> a input dialog facet is used for requesting the visit type before the visit is created
<2> by redefining the `groupTable` with the same ID as in the parent screen: "petsTable", the merging of the two screen descriptors is initiated
<3> the button is appended to the existing `buttonsPanel` component

The business logic of the screen is also extended accordingly. The controller subscribes to the close event of the input dialog.


.KantoPetBrowse.java
[source,java]
----
@UiController("petclinic_Pet.browse")
@UiDescriptor("rocky-mount-pet-browse.xml")
public class KantoPetBrowse extends PetBrowse {

    @Inject
    protected GroupTable<Pet> petsTable;
    @Inject
    protected Notifications notifications;
    @Inject
    protected VisitCreationService visitCreationService;
    @Inject
    protected ScreenBuilders screenBuilders;
    @Inject
    protected MessageBundle messageBundle;

    @Subscribe("createVisitForPetDialog")
    protected void onCreateVisitForPetDialogClose(CloseEvent event) {
        if (event.getCloseAction().equals(InputDialog.INPUT_DIALOG_OK_ACTION)) {
            final VisitType visitType = (VisitType) event.getValues().get("visitType");

            final Visit createdVisit = visitCreationService
                .createVisitForPet(petsTable.getSingleSelected(), visitType); // <1>

            notifications.create(NotificationType.TRAY)
                            .withCaption(messageBundle.getMessage("visitCreated"))
                            .show();

            screenBuilders.editor(Visit.class, this)
                .editEntity(createdVisit)
                .withOpenMode(OpenMode.DIALOG)
                .show();

        }
    }
}
----
<1> the creation of the Visit is delegated to the `VisitCreationService`, which is only part of the Kanto-Petclinic project.

The `VisitCreationService` is a new CUBA Service that is not part of the original Petclinic platform. Instead, we create this service exclusievely for the Kanto-Petclinic project:


.VisitCreationServiceBean.java
[source,java]
----

@Service(VisitCreationService.NAME)
public class VisitCreationServiceBean implements VisitCreationService {

    @Inject
    protected DataManager dataManager;
    @Inject
    protected TimeSource timeSource;

    @Override
    public Visit createVisitForPet(Pet pet, VisitType visitType) {

        final Visit visitForPet = dataManager.create(Visit.class);

        visitForPet.setPet(pet);
        visitForPet.setVisitStart(timeSource.now().toLocalDateTime());
        visitForPet.setVisitEnd(timeSource.now().toLocalDateTime().plusHours(1));

        visitForPet.setType(visitType);

        return dataManager.commit(visitForPet);
    }
}
----

With this code in place, the customizations for the Kanto-Petclinic are finished. The application can now be shipped to the customer. Let's look at the second customer "Alabastia-Petclinic" so see some other extensions in action.

=== Alabastia-Petclinic

The Alabastia Petclinic extends the original Project with the following customer specific behavior:

* give users the ability to assign Treatment Rooms to Visits
* automatically pre-select the Assigned Nurse based on the current user when creating a new Visit
* automatically pre-select the Nurses Treatment Room for a new Visit


Those changes require some more invasive additions to the Petclinic product. The assignment of the treatment rooms needs to be stored in two additional Entities, that we are going to create only for this project. Additionally, it requires some UI adjustments that will take care of the automatic pre-selection.

==== Treatment Rooms for Visits

In order to assign treatment rooms to visits, the rooms itself need to be managed in a dedicated entity:


.TreatmentRoom.java
[source,java]
----
@Table(name = "LANCASTERPETCLINIC_TREATMENT_ROOM")
@Entity(name = "alabastiapetclinic_TreatmentRoom")
public class TreatmentRoom extends NamedEntity {

    @Column(name = "ROOM_NUMBER", nullable = false)
    private String roomNumber;

}
----

The entity annotation assigns the `TreatmentRoom` entity the namespace of the Alabastia Petclinic project, which helps to differentiate between the Petclinic core entites and the additional entities.

Nevertheless, it is e.g. possible to mix and match with entities of the Petclinic platform project. In this case the `TreatmentRoom` entity extends the mapped superclass `NamedEntity` which is defined in the Petclinic platform.

After storing the information of the Rooms itself, it is required to store the information of which treatment room is the default one for each Nurse. Therefore, we will create a mapping entity called `DefaultTreatmentRoom` which links to a treatment room and a user entity:


.DefaultTreatmentRoom.java
[source,java]
----
@Entity(name = "alabastiapetclinic_DefaultTreatmentRoom")
public class DefaultTreatmentRoom extends StandardEntity {

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "USER_ID")
    private User user;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "TREATMENT_ROOM_ID")
    private TreatmentRoom treatmentRoom;

}
----

Now the last entity extension that needs to be made is to link a Visit with a Treatment Room. This is done via Entity extensions as we have already seen in the Kanto-Petclinic example:


.AlabastiaVisit.java
[source,java]
----
@Extends(Visit.class)
@Entity(name = "alabastiapetclinic_AlabastiaVisit")
@DiscriminatorValue("AlabastiaVisit")
public class AlabastiaVisit extends Visit {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TREATMENT_ROOM_ID")
    private TreatmentRoom treatmentRoom;

    public TreatmentRoom getTreatmentRoom() {
        return treatmentRoom;
    }

    public void setTreatmentRoom(TreatmentRoom treatmentRoom) {
        this.treatmentRoom = treatmentRoom;
    }
}
----

With those entity changes, we have everything in place to allow the UI automatically pre-populate the correct values for `assignedNurse` and `treatmentRoom`. The assigned nurse will just be the current user, whereas the treatmentRoom is looked up by the room assigned in the `DefaultTreatmentRoom` for the current user.


.AlabastiaVisitEdit.java
[source,java]
----
@UiController("petclinic_Visit.edit")
@UiDescriptor("alabastia-visit-edit.xml")
public class AlabastiaVisitEdit extends VisitEdit {

    @Inject
    protected DataManager dataManager;
    @Inject
    protected UserSession userSession;
    @Inject
    protected EntityStates entityStates;

    @Subscribe
    protected void onAfterShow(AfterShowEvent event) {

        if (entityStates.isNew(getEditedEntity())) {
            getEditedEntity().setAssignedNurse(
                currentUser()
            );

            defaultTreatmentRoomFor(
                currentUser()
            ).ifPresent(defaultTreatmentRoom -> // <1>
                initTreatmentRoom(defaultTreatmentRoom.getTreatmentRoom())
            );
        }
    }

    private void initTreatmentRoom(TreatmentRoom treatmentRoom) {
        final AlabastiaVisit visit = (AlabastiaVisit) getEditedEntity(); // <2>
        visit.setTreatmentRoom(treatmentRoom);
    }

    private User currentUser() {
        return userSession.getCurrentOrSubstitutedUser();
    }

    private Optional<DefaultTreatmentRoom> defaultTreatmentRoomFor(User user) {
        return dataManager
            .load(DefaultTreatmentRoom.class)
            .query("e.user = ?1", user)
            .view(viewBuilder ->
                viewBuilder.add("treatmentRoom", View.MINIMAL)
            )
            .optional();
    }
}
----
<1> the default treatment room is looked up via the dataManager. If there is a mapping defined for the current user the room will be set for the visit.
<2> in order to use the methods of the extension, the Visit entity has to be casted to `AlabastiaVisit`. As we have extended the entity, we can be sure that CUBA will always use `AlabastiaVisit` instead of `Visit`. Therefore, it is safe to cast here.

