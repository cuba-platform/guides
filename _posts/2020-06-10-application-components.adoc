---
compatible_cuba_versions: 7.1+
compatible_java_versions: 8+
project_id: cuba-petclinic-unit-testing
permalink: unit-testing
---
= Product Customizations with Application Components
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Product Customizations with Application Components
:page-excerpt:In this guide you will learn how customer-specific solutions can be created based on a standard product. We will leverage the capabilities of CUBAs application components to modularize the overall application.
:page-root: ../../../
:project_id: cuba-petclinic-unit-testing
:java_version: 8
:cuba_version: 7.1
:page-icone: images/unit-testing/guide_icone.svg

In this guide you will learn how customer-specific solutions can be created based on a standard product. We will leverage the capabilities of CUBAs application components to modularize the overall application.

== What we are going to build

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA Petclinic] example to show how two customer-specific extensions `Kanto-Petclinic` and `Alabastia-Petclinic` can be created and how specific extensions are created:

* convert the Petclinic project into a CUBA application component
* create two CUBA applications: `Kanto-Petclinic` and `Alabastia-Petclinic` that use the CUBA Petclinic as a basis

=== Kanto-Petclinic

The Kanto Petclinic extends the original Project with the following customer specific behavior:

* additional attribute `previousIllnesses` to the Visit Entity
* allow users to create a Visit for today from the Pet Browse screen

=== Alabastia-Petclinic

The Alabastia Petclinic extends the original Project with the following customer specific behavior:

* give users the ability to assign Treatment Rooms to Visits
* automatically pre-select the Assigned Nurse based on the current user when creating a new Visit
* automatically pre-select the Nurses Treatment Room for a new Visit


include::includes/guide_requirements.adoc[]

== Overview

Application components in CUBA can be used to create reusable components of functionality that can be leveraged in other CUBA applications. Depending on how much functionality the application component contains, it can have the form of a small addon, that enriches your application with a particular aspect.

But application components can also be used to represent a complete application. In this case, the application component contains all the entities, screens and business logic that the standard application consists of. Then the actual application just uses the application component and only puts very slight adjustments on it.

This second scenario is what we will be covering in this guide in particular. In the example we will convert the Petclinic application into an application component. Then we will create two applications, that use the Petclinic and adjust it to their customer-specific needs.

With this approach we can incorporate requirements from customers, that would like the standard product (Petclinic) to be adjusted in order to use it. Application components give us a compile-time extension mechanism for this problem.


=== Different Extension Mechanisms

Before we dive into the concrete example of the Petclinic, let's explore the differences between compile-time and runtime extensions. Depending on the required capabilities, deployment- and distribution mechanisms of the product one or the other might be more suitable.

==== Runtime Extensions: Plugins, Scripting & Configuration

The first extension mechanism of a CUBA application is a runtime extension. The main characteristic of that extension is, that during the build process one application artifact like a `war` binary has been created. This binary is always the same and distributed to all customers. The extension part of the application does not change the original binary e.g. by replacing certain classes.

Instead, the extensions are added at runtime / deployment time of the application. This can be done in various forms. One example is a plugin architecture. In this case it would be additional jar files, which contain the plugins for the application. Those jar files are placed into the application server. Oftentimes it is required to restart the application to pick up those plugins.

Such a jar file plugin can contain source code. Normally it is used for implementing certain interfaces that are defined within the main application, in order to fulfil / replace a particular functionality.

The next step, which is less powerful is Scripting. In CUBA there are several mechanisms / examples built-in for scripting in place. Scripting allows to programmatically define particular pre-defined areas of the functionality in the application. One example of that inside CUBA itself is the Constraint definition within the security groups administration. It is possible to define a groovy script, which will determine if a particular user has access to a particular resource like an entity record.

Oftentimes scripting is combined with configuration. Taking the Constraint definition once again: the groovy script is just one part of the dynamic configuration. It actually belongs to a bigger "Constraint configuration", which includes a link to an Entity, a type of operation etc.

Configuration also allows certain extension capabilities. But those extension points are very limited in terms of the overall application and they also need to be defined within the application itself.

==== Compile-Time Extension: Application Component

The second extension mechanism of a product is a compile-time extension. This type of extensions happen during the production process of the software. It may happen at development time through customer specific extensions / adjustments of the standard product. Alternatively it can also happen at the time the binary is created e.g. by adding certain additional `jar` files into the binary.

In this case, everything is still possible to change, because it is very early in the software production process. Additional entities can be created, business logic can be overridden and customer-specific UIs can be created.


== Petclinic as a Product Line

Picking up the Petlinic example from above, what we will do in this guide is to make the Petclinic product not a standalone software anymore, but rather a Product Line. The base product is the Petclinic example as we know it. Additionally there are extensions made for particular customer type or even a particular customer.

Those extensions are itself CUBA applications (`Kanto-Petclinic` and `Alabastia-Petclinic`) that uses the Petclinic base product as an application component. With that we will leverage the compile-time extension mechanism for a CUBA application.

Additionally, we will go through an example of a runtime extension of the petclinic, which not bound to the originally delivered binary, but rather acts as an addon to the application.

=== Making the Petclinic Project an Application Component

In order to leverage the Petclinic project as a product line, it is required to understand what makes up a CUBA application component and where it is different over a regular CUBA application. In fact, the difference it is not very much - only one particular file called `app-component.xml`. This application component descriptor file marks a CUBA application additionally to be used as an application component. This means - it can be used by other CUBA applications.

Besides that, nothing really changed. The application component can still be used as a regular CUBA application. It can be started in CUBA Studio, business logic can be created, UIs can be generated etc.

Used by other CUBA applications in this case means not only that the functionality of the application component shows up in the resulting application. Also it is possible to interact with any part of the application component from inside the target application. Entities (like the `Pet` entity) can be referenced, Spring beans can be overridden, UI screens can be extended or replaced etc.

Let's look into the `app-component.xml` of the Petclinic example:

.app-component.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<app-component xmlns="http://schemas.haulmont.com/cuba/app-component.xsd"
  dependsOn="com.haulmont.cuba, com.haulmont.addon.helium">

  <module name="global" blocks="*">
    <artifact name="petclinic-global" appJar="true"/>

    <property name="cuba.persistenceConfig" value="+com/haulmont/sample/petclinic/persistence.xml"/>
    <property name="cuba.metadataConfig" value="+com/haulmont/sample/petclinic/metadata.xml"/>
    <property name="cuba.viewsConfig" value="+com/haulmont/sample/petclinic/views.xml"/>
  </module>
  <module name="core" dependsOn="global" blocks="core">
    <artifact name="petclinic-core" appJar="true"/>
    <property name="cuba.mainMessagePack" value="+com.haulmont.sample.petclinic.core"/>
    <!-- ... -->
  </module>
  <!-- ... -->
</app-component>
----

This file contains a formal description of the structure of the application component. It exposes a couple of `module` elements. Those modules can declare `artifact` elements as well as `property` elements that should be exposed for this application component.

CUBA mainly uses this information for configuring the right application properties (and values) as well as downloading the correct dependencies.
Normally this file does not need to be changed manually at all, because it only contains static information about the structure of the application component.

TIP: Through CUBA Studio it is possible to generate the application component descriptor via the Menu: `CUBA > Advanced > App Component Descriptor`.


=== Using the Petclinic Application Component in a CUBA Application

After making the Petclinic project an application component, it is necessary to install it to a maven repository, so that the dependency mechanisms from CUBA (in particular from Gradle) can download the application component in the target application.

For installing there is a dedicated gradle task, that has to be performed in the application component project: `./gradlew install` (the equivalent Menu entry in CUBA Studio is `CUBA > Advanced > Install App Component`).

With that task, the application component is build and put into the local maven repository of the computer, in particular in the `.m2` directory within the users home directory:

image::application-components/local-maven-repository.png[]

After installing the application component, it can be used in the target application. One prerequisite for using an application component from the local maven repository, is inside of the `repositories` block of the `build.gradle` file the maven local repository needs to be mentioned:

.build.gradle
[source,groovy]
----
repositories {
    mavenLocal()
    //...
}
----
In order to use it, the dependency can be installed through CUBA Studio. Via `CUBA > Marketplace...` an application component can be found. In this case, the petclinic application component is not in the public CUBA Marketplace, but rather in our local computer. Therefore, it does not appear in the list. On the top right, there is a button called `Install add-on manually`, which allows to enter the coordinates of the application component: `com.haulmont.sample.petclinic:petclinic-global:2.0`.

TIP: When using a development approach within a team the normal way of handling such a dependency is to use a dedicated maven repository like `Nexus`, `Artifactory` or `Github Packages` where the application component binaries are stored. In this case the application component does not need to be installed locally on everyone's machine.

With those preconditions in place, the target application is ready to start. It will contain all the entities and screens from the application component as well as its own.

== Petclinic Extensions

As described in the beginning, we will do certain extensions to the different customers and their dedicated applications.

=== Kanto-Petclinic

We will start of with the Kanto-Petclinic. This project only needs slight adjustments to the Petclinic core. There is one additional information to store for a Visit, which described previous illnesses. Additionally, in the Kanto Petlinic there are a lot of emergency visits. This requires the nurses to oftentimes create Visits of a particular type for today. In order to support this use-case, there should be a shortcut way of creating this kind of visit.


=== Alabastia-Petclinic

The Alabastia Petclinic extends the original Project with the following customer specific behavior:

* give users the ability to assign Treatment Rooms to Visits
* automatically pre-select the Assigned Nurse based on the current user when creating a new Visit
* automatically pre-select the Nurses Treatment Room for a new Visit
