---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-data-model-composition
permalink: data-modelling-composition
---
= 数据建模： 组合
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: 数据建模: 组合
:page-excerpt: 数据建模指南: 什么是组件及什么时候应该在实体关系中使用组合
:page-icone: images/data-model-composition/guide_icone.svg
:page-root: ../../../
:project_id: cuba-petclinic-data-model-composition
:page-url-first-image: https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-composition/master/img/login-screen.png
:java_version: 1.8
:cuba_version: 7.0

本指南将覆盖实体间的组合关系。将会演示关联(Association) 和组合(Composition)之间的不同。会使用示例探究两种不同的组合：一对多组合和一对一组合。

== 将要构建的内容

本指南对 https://github.com/cuba-platform/cuba-petclinic[CUBA 宠物诊所] 进行了增强，以演示实体间组合关系的各种用例。特别是会覆盖以下用例：

*  `Owner` 实体与  `Address` 建立关联
* `Pet` 包含多个 `HealthRecord` 实例，每个 `HealthRecord` 包含多个 `HealthRecordAttachment`。
* The `Employee` entity has a detail entity for storing the employee record: `EmployeeRecord` which will be entered during the creation process of the `Employee`
* `Employee` 实体有一个用于存储雇员记录的详情实体：`EmployeeRecord` ，这实体是在雇员的创建过程中输入。 ????

=== 最终应用程序

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-composition/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-data-model-composition/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]

== 组合 vs. 关联

CUBA 平台支持两种类型的实体间关系： `关联(ASSOCIATION)` 和 `组合(COMPOSITION)` 。 关联是对象间可以独立存在的关系。而组合，换句话说就是用于 “主-从”关系，这种关系中明细实实体不能脱离主实体存在。

在宠物诊所示例中，`Owner` 和 `Addresses` 之间的关系可以看作是组合：一个不属于任何 `Owner` 的 `Addresses` 没有任何意义 （在这个应用程序范围内）

典型情况下，组合关系的实体总是一起编辑，因为这样很自然、合理。用户打开  `Owner` 编辑界面，可以看到 `addresses` 列表，对 `Owner` 信息和 `addresses` 列表进行编辑，最后将所有更改在一个事务中一起提交到数据库， 并且只能在用户确定保存主实体(`Owner`) 时才保存。



== 一对多组合

在本指南中会演示组合关系的不同用法。组合可以是 `ONE-TO-MANY` ，也可以是  `ONE-TO-ONE`。在应用程序中甚至可以使用多级嵌套组合。


TIP: 随着 CUBA 7 的发布，CUBA 应用程序不再限制嵌套层数。但是，如果嵌套层数太多，复杂的界面操作常常会使用户迷惑。因此， 建议不要使用太多层次的嵌套组合。

=== 一对多: 一层嵌套

使用 `Owner` 和 the `Address` 实体作为一对多组合的示例：

image::data-model-composition/composition_domain_model_one_level.png[align="center"]

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/owner/Address.java[Address.java] -  `Address` 实体必须关联一个 `Owner` 。
+
NOTE: 在Studio提供的实体设计器中，对 `owner` 实体进行以下设置： *Attribute type* - `ASSOCIATION`, *Cardinality* - `MANY_TO_ONE`, *Mandatory* - `on` 。


* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/owner/Owner.java[Owner.java] - `Owner` 实体包含了一个一对多关系的 `addresses` 集合属性。对应的字段使用了 `@Composition` 注解来实现组合，使用 `@OnDelete` 实现级联软删除。
+
NOTE: 在 Studio 提供的实体设计器中，对 `addresses` 属性进行以下设置：*Attribute type* - `COMPOSITION`, *Cardinality* - `ONE_TO_MANY`, *On delete* - `CASCADE` 。

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/views.xml[views.xml] - `Owner` 实体的  `owner-with-pets-and-addresses` 编辑界面包含 `addresses` 集合属性。 `Addresses` 本身使用了 `_local` 视图，这是因为 `Addresses` 的 `owner` 属性只在 `Addresses` 创建时设置并且后续不会更改，所以就不需要加载它。


* https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/owner/owner/owner-edit.xml[owner-edit.xml] -  `Owner` 编辑界面的XML描述中为  `Owner` 实例定义了一个数据容器，同时也包含了一个嵌套的 `addresses` 集合容器。 XML描述中也包含一个用于管理 `Address` 实例的表格。

* https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/owner/address/address-edit.xml[address-edit.xml] -  `Address` 实体的标准编辑界面。

最终，`Owner` 实例的编辑过程如下：

image::data-model-composition/one-level-owner-editor-address-composition.png[align="center",link="images/data-model-composition/one-level-owner-editor-address-composition.png"]

`Owner` 编辑界面显示了一个 `addresses` 列表。



修改过的 Address 实例并没有保存到数据库， 只是提交到了  Owner 编辑界面的 `DataContext` 。 用户可以创建新的实例，也可以删除已有实例。所有的更改都会提交到 `DataContext`。
在用户点击 Owner 编辑界面上的 *OK* 按钮时，修改过的 `Owner` 实例和 `Address` 实例会被提交给 `dataManager.commit()` 方法，并在同一个事务中保存到数据库。



=== 一对多：两层嵌套

Composition can also be multiple-level. The next example shows a Composition of two levels. In the Petclinic there is a need to store health records of the pets. The `Pet` -> `HealthRecord` relationship is another composition. However, the `HealthRecord` also has another composition since there can be multiple `Attachment` instances created for a given health record.

image::data-model-composition/composition_domain_model_two_levels.png[align="center"]

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/pet/Pet.java[Pet.java] - the `healthRecord` attribute of the `Pet` class is marked as `@Composition` and `@OnDelete`.

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/pet/HealthRecord.java[HealthRecord.java] - the `attachments` attribute of the `HealthRecord` class is marked as `@Composition` and `@OnDelete` similarly to the `healthRecords` attribute of the `Pet` class.

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/views.xml[views.xml] - the `health-record-with-attachments` view of the `HealthRecord` class contains the `attachments` collection attribute. This view is used in the `pet-with-owner-and-type-and-health-records` view of the `Pet` entity which acts as the root view of the edit screen.

* https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/pet/pet/pet-edit.xml[pet-edit.xml] - the XML descriptor of the `Pet` editor screen defines a data container for the `Pet` instance and a nested collection data container for its `healthRecords`. It also contains a table for managing the `HealthRecord` instances. The screen uses the `pet-with-owner-and-type-and-health-records` view as a root view for this edit screen.

+
[TIP]
====
CUBA 7+ removed the previous need to define datasources for the second level of nested compositions in the editor of the top level entity with the release of data containers. In CUBA 7+ this definition is *not* required anymore.
====

* https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/pet/healthrecord/healthrecord/health-record-edit.xml[health-record-edit.xml] - the XML descriptor of the `HealthRecord` editor screen defines a data container for the `HealthRecord` instance and a nested collection data container for its `attachments`. It also contains a table for managing the `HealthRecordAttachment` instances.


As a result, the updated instances of the `HealthRecordAttachment`, as well as the `HealthRecord` instances, will be saved to the database only with the `Pet` instance in the same transaction.

==== Health Record Composition within the Pet Editor
image::data-model-composition/two-levels-pet-editor-health-records-composition.png[align="center",link="images/data-model-composition/two-levels-pet-editor-health-records-composition.png"]

==== Health Record Attachment Composition within the Health Record Editor
image::data-model-composition/two-levels-healthRecord-editor-health-record-attachments-composition.png[align="center",link="images/data-model-composition/two-levels-healthRecord-editor-health-record-attachments-composition.png"]


=== More Levels of Nesting

As stated above, CUBA 7+ does not have the restriction of maximal two levels of nesting for composition anymore. This means that three (or more) levels of nesting are possible. The example for two levels of nesting can be extended towards: `Owner` -> `Pet` -> `Health Record` -> `Health Record Attachment` and in fact it has been done within the demo application. It is also possible to combine the usage of One-to-Many and One-to-One compositions within a Composition chain.

Having too many levels of composition has to be treated with caution, though. It requires an additional burden on the user, to understand at which point which data is stored.


== One-to-One Composition

Besides the above explained Composition of type `ONE-TO-MANY`, there is also the possibility to define Composition of type `ONE-TO-ONE`. This type of Composition is useful when it is only possible to have one item of the child entity. An example in the petclinic is the following scenario:

The employees of the Petclinic have to be managed (like Vets, Nurses etc.). Therefore an `Employee` entity is defined. For each `Employee` instance there is an associated `EmployeeRecord` entity which stores information about the work related information of this employee.


image::data-model-composition/composition-one-to-one.png[align="center"]


* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/employee/Employee.java[Employee.java] - the `Employee` entity contains an optional link to `EmployeeRecord` annotated with `@Composition`.

* https://github.com/cuba-guides/{project_id}/blob/master/modules/global/src/com/haulmont/sample/petclinic/entity/employee/EmployeeRecord.java[EmployeeRecord.java] - the `EmployeeRecord` entity.

On a UI level it is possible to deal with One-to-One composition in two different ways. Normally, One-to-One compositions are displayed as a single entry in the form of the master entity. The details of the child entity are entered in a dedicated edit screen for this entity. But it is also possible to enter values for both entites in the same edit screen. Below both options will be shown.


=== One-to-One with a Details Screen

* https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/employee/employee/employee-edit.xml[employee-edit.xml] - the employee edit screen descriptor. It contains a nested data container for the `EmployeeRecord` instance. In order to load the nested instance, the root data container uses the `employee-with-employee-record-view` view of the `Employee` entity that includes the `employeeRecord` attribute.

The definition of the `employeeRecord` property in the `employee-edit.xml` is defined as a `pickerField` component which contains the actions `OpenAction` (with special type `picker_open_composition`) and `ClearAction`:

[source, xml]
----
<pickerField id="employeeRecordField" property="employeeRecord">
    <actions>
        <action id="open" type="picker_open_composition"/>
        <action id="clear" type="picker_clear"/>
    </actions>
</pickerField>
----

As a result, employee editing works as follows:


image::data-model-composition/composition-one-to-one-editor-open-action.png[align="center",width="600"]

When the open action is invoked, a new instance of `EmployeeRecord` is created and its edit screen is shown. When *OK* is clicked in the employee record editor, the employee record instance is not saved to the database, but only to the `employeeRecordDc` data container of the employee edit screen.

The picker field displays the instance name of the `EmployeeRecord` entity:

image::data-model-composition/composition-one-to-one-editor-open-action-instance-name.png[align="center",width="600"]

When a user clicks *OK* in the employee edit screen, the updated `Employee` instance together with the `EmployeeRecord` instance is submitted to the `DataManager.commit()` method and saved to the database within a single transaction.

If the user invokes the clear action of the picker field, the `EmployeeRecord` instance is deleted and the reference to it is cleared in the same transaction after the user commits the employee editor.


=== One-to-One Composition with a Single Editor


It is often convenient to edit the One-to-One composition in a single editor. The following example shows how the `EmployeeRecord` can be edited within the `Employee` editor screen.

The https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/employee/employee/employee-single-editor-edit.xml[employee-single-editor-edit.xml] descriptor contains the main `employeeDc` and the nested `employeeRecordDc` data containers:

[source, xml]
----
<data>
    <instance id="employeeDc"
              class="com.haulmont.sample.petclinic.entity.employee.Employee"
              view="employee-with-employee-record-view">
        <loader/>
        <instance id="employeeRecordDc" property="employeeRecord"/>
    </instance>
</data>
----

Fields for editing both entities are defined in the same editor either a single form or multiple forms:

[source, xml]
----
<form id="form" dataContainer="employeeDc">
    <textField id="firstNameField" property="firstName"/>
    <textField id="lastNameField" property="lastName"/>
    <dateField id="birthdateField" property="birthdate"/>
</form>
<form id="employeeRecordForm" dataContainer="employeeRecordDc">
    <textField id="personellNumberField" property="personellNumber" datatype="int"/>
    <textField id="amountSickDaysFild" property="amountSickDays" datatype="int"/>
</form>
----

In the https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/employee/employee/EmployeeSingleEditorEdit.java[EmployeeSingleEditorEdit.java] controller an `EmployeeRecord` instance will be created and linked to the new `Employee` instance when the latter is just created:

.EmployeeSingleEditorEdit.java
[source, java]
----
@Inject
protected DataContext dataContext;

@Subscribe
protected void onInitEntity(InitEntityEvent<Employee> event) { // <1>
    Employee employee = event.getEntity();
    EmployeeRecord employeeRecord = createEmployeeRecord();
    employee.setEmployeeRecord(employeeRecord);
}

private EmployeeRecord createEmployeeRecord() {
    return dataContext.merge(metadata.create(EmployeeRecord.class)); // <2>
}
----
<1> the initialization of the `EmployeeRecord` can be defined when the `InitEntityEvent` is fired
<2> an instance of `EmployeeRecord` is created and merged in the current `dataContext`

Now, both linked entities can be created and edited in one editor screen.


image::data-model-composition/composition-one-to-one-single-editor.png[align="center"]


== Summary

In this data modelling guide the Composition relationship was described. Compositions are valuable if a master-detail relationship between two entities should be modelled, where the detail entities can only exist if the corresponding master entity exists.

Composition structures can exist in 1:1 and 1:N form. Furthermore, nested composition can be created with multiple levels. The corresponding UI screens treat Composition relationships in a special way. Detail entities are only stored during the creation process of the master entity at the point in time when the master entity is stored.