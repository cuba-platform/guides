---
compatible_cuba_versions: 7.0
project_id: cuba-petclinic-application-logging
permalink: logging-in-cuba-applications
---
= Logging in CUBA applications
:showtitle:
:page-navtitle: Logging in CUBA applications
:page-excerpt: Guide on why and how to use logging in a CUBA application in order to get insights
:page-root: ../../../
:project_id: cuba-petclinic-application-logging
:java_version: 1.8
:cuba_version: 7.0

In order to get insights into a running CUBA application, Logging is one crucial part to get in place. The Java ecosystem has a very mature mechanisms to do application logging. This guide show how this ecosystem can be leveraged in a CUBA application.

== What will be build

This guides enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA petclinic] example to show how logging can be integrated, configured and viewed as part of the application itself or with the help of external tools.


=== Final Application

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-datamanager/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-datamanager/master/img/login-screen.png"/></a>
++++

include::/includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]


== Why application logging is essential

Logging information about the running application is essential in order to get insights on how the application behaves, what unexpected behavior occurs and how the users are interacting with the system.

Logging is a common pattern of application development. The developer writes statements into the application source code indicating that certain actions happened. In the following example two possible log messages are written. In case of a successful saving of the `Pet` instance, an informal message is written with the details of the pet that has been stored. In case of a failure of storing the Pet, an error message is written with information about the failure.


.PetServiceBean.java
[source,java]
----
private Pet savePet(Pet pet) {
    try {
      Pet savedPet = dataManager.commit(pet);
      log.info("Pet " + pet + " was saved correctly");
      return savedPet;
    }
    catch(Exception e) {
      log.error("Pet " + pet + " could not be saved", e);
      return null;
    }

}
----

Those messages will be written in a configured place that some administrator or developer has access to for later use. Normally this are plain text files, but it is also possible to store the logging information in a Database or a centralized logging service.

For development purposes the developer normally has the ability to debug the source code. For a running application this is normally not the case. Either because of security reasons or simply because the application is not run on a server that is under the control of the developer.

Therefore logging is the another tool in the toolbox of a developer in order to do diagnostics of a running application.

== The Java logging ecosystem

In the Java ecosystem logging has (as in a lot of other ecosystems as well) played a substantial role. There are various mechanisms and abstractions out there on how to actually interact with the logging mechanisms of the platform the application is running on.

Mainly these are various APIs of the JVM and different logging libraries that encapsulate the technical concern of logging to a file / database from the abstraction of "writing a log message".

In recent years a commonly used combination has been adopted in the Java ecosystem:

- Slf4J
- Logback

Slf4J is an abstract API that encapsulates the concrete details of the logging library. It offers different methods for logging information to the logging system with different servity levels (`DEBUG`, `INFO`, `WARN` etc.).

Logback on the other hand is the logging library that fulfils this API and does the heavy lifting of writing the message to a log appender. It contains the options to configure where the log messages should go to.

== How to log in a CUBA application

The usage of logging libraries within a CUBA application does not differ from other Java application in this regard. CUBA is by default configured with Sl4fJ and Logback in place. The framework itself uses logback for information about the execution of production. In order to log information within a class, an instance of a Logger has to be created in the class that wants to log information.

.PetEdit.java
[source,java]
----
@UiController("petclinic_Pet.edit")
@UiDescriptor("pet-edit.xml")
@LoadDataBeforeShow
public class PetEdit extends StandardEditor<Pet> {

    private static final Logger log = LoggerFactory.getLogger(PetEdit.class); // <1>

    @Subscribe
    protected void onInit(InitEvent event) {
        log.debug("Pet editor opened"); // <2>
    }

}
----
<1> Logger configured for this class is defined through Slf4J
<2> write debug log message when opening the screen

=== View log messages through CUBA UI

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-messages.png"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-messages.png"/></a>
++++

=== Logging Levels

Slf4J allows to define the following logging levels:

- TRACE
- DEBUG
- INFO
- WARN
- ERROR
- FATAL

== Adjust logging configuration

In order to include the `petId` field into the log output the above mentioned logback configuration comes into play. Logback (alongside with other logging libraries) allows heavy customization on how and where the log information it processed and written to an output.

Generally there are two options to adjust the configuration of logback. On the one side there is a configuration file called `logback.xml` where the configuration can be expressed. This adjustments happen at deployment time. Alternatively logback can (to a certain extend) be configured at runtime. CUBA offers a UI for adjusting logging configuration for this purpose.

=== At deployment: logback.xml configuration file

The configuration file `logback.xml` is the main place to adjust the configuration of logback. In a CUBA application this file is located in `deploy/tomcat/conf/logback.xml` (in case of http://fixMe[fast deployment] option). It looks like this:


.logback.xml
[source,xml]
----
<configuration debug="false" packagingData="true">

    <property name="logDir" value="${catalina.base}/logs"/>

    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender"> // <1>
        <file>${logDir}/app.log</file>

        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>DEBUG</level>
        </filter>

        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread%X{cubaApp}%X{cubaUser}] %logger - %msg%n</pattern> // <2>
        </encoder>
    </appender>

    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender"> // <3>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %-5level %-40logger{36}- %msg%n</pattern>
        </encoder>
    </appender>

    <root>
        <appender-ref ref="Console"/>
        <appender-ref ref="File"/>
    </root>

    <logger name="com.haulmont.sample.petclinic" level="DEBUG"/> // <4>
    <logger name="com.haulmont.cuba" level="DEBUG"/>
    <logger name="com.haulmont.cuba.core.sys" level="INFO"/>

    <!-- ... -->

</configuration>

----
<1> a file appender to write log messages to the logfile `app.log`
<2> `pattern` configures how a single log message line within the file should look like
<3> another appender writes the log messages to `STDOUT` (with different options)
<3> logging levels can be configured on a per class / package basis

CUBA by default configures multiple log appenders. An appender describes where the log information should be written to. There are multiple appenders available out of the box. Each appender has options to configure its behavior (like how the log message should be formatted, which information should be logged etc.). Common Log appenders are `FileAppender`, `ConsoleAppender` or `DatabaseAppender`.

The configuration of loggers allow to define on a per class / package basis the threshold. This means that for certain subparts of the application, it is possible to get log messages that have been written as `DEBUG` while for certain other application parts it is only necessary to see log messages of `WARN` and `ERROR`.

In the example above the package`com.haulmont.sample.petclinic` is set to level `DEBUG`. This means, that it will output all log messages that have _at least_  the level `DEBUG`. `TRACE` log messages would not be displayed.


=== At runtime: CUBA logging UI

Adjusting the configuration of the file requires a restart of the application. For temporary debugging sessions it is oftentimes helpful to not have to restart the server only to adjust the logging level or a certain subpart of the application code.

For this use-case a CUBA application allows to reconfigure the levels of existing loggers and also add loggers at runtime trough a user interface.


++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-settings.png"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-settings.png"/></a>
++++


=== Set logging context with MDC

Once the application has certain amount of logging information certain information get repeated in a lot of logging messages. In the petclinic example a lot of log messages would contain the Pet ID in order to get the context information in a fast manner. For those kinds of information, there is a context in Logback, called _MDC_.

MDC allows to set certain values into a context, that gets logged every time alongside with the actual logging message. This way the context can be set once and the developer writing the actual logging statement does not need to include it into the log message anymore.

In the example of the petclinic, the `PetContactFetcherBean` leverages the MDC context in the following manner: Directly after invoking the method `Optional<Contact> findContact(Pet pet)` the identification number of the Pet is set into the MDC context like this:


.PetContactFetcherBean.java
[source,java]
----
@Component(PetContactFetcher.NAME)
public class PetContactFetcherBean implements PetContactFetcher {

    private static final Logger log = LoggerFactory.getLogger(PetContactFetcherBean.class);


    @Override
    public Optional<Contact> findContact(Pet pet) {

        MDC.put("petId", pet.getIdentificationNumber()); // <1>

        log.debug("Searching Contact for Pet"); // <2>

        Optional<Owner> petOwner = loadOwnerFor(pet);

        if (petOwner.isPresent()) {
            log.debug("Found Owner: {}", petOwner);

            // ...

            if (isAvailable(telephone)) {
                return createContact(telephone, ContactType.TELEPHONE);
            }

            // ...

        } else {
            return Optional.empty();
        }
    }

    private Optional<Contact> createContact(String contactValue, ContactType contactType) {

        Contact contact = new Contact();
        contact.setValue(contactValue);
        contact.setType(contactType);

        log.info("Contact created: {}", contact); // <3>

        MDC.remove("petId"); // <4>

        return Optional.of(contact);
    }

    // ...

}

----
<1> the Pets identification number is registered in the context under the key `petId`
<2> the following logging messages do not need to include the Pet ID within the log message itself
<3> the lifetime of a value in the MDC is independent of method boundaries
<4> the key `petId` of the MDC is cleaned up at the end of the method


Now that the MDC has values in it, the next step is to reconfigure logback in order to see the dedicated MDC values in the log output.


.logback.xml
[source,xml]
----
<configuration debug="false" packagingData="true">

    <!-- ... -->

    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender">

        <!-- ... -->

        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread%X{cubaApp}%X{cubaUser}] [Pet: %X{petId}] %logger - %msg%n</pattern> // <1>
        </encoder>

    </appender>

    <!-- ... -->

</configuration>

----
<1> `%X{petId}` takes the value with the key `petId` of the MDC and writes it to the log file


The resulting logging output contains the Pet identification number:

[source,bash]
----
2018-12-13 08:54:41.345 DEBUG [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Searching Contact for Pet
2018-12-13 08:54:41.354 DEBUG [http-nio-8080-exec-7/petclinic-core/admin] [Pet: 205] c.h.c.c.a.RdbmsStore - load: metaClass=petclinic_Owner, id=79fa17b9-a130-207d-5091-f79cceb9cf99, view=com.haulmont.sample.petclinic.entity.owner.Owner/_local
2018-12-13 08:54:41.371 DEBUG [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Found Owner: Optional[com.haulmont.sample.petclinic.entity.owner.Owner-79fa17b9-a130-207d-5091-f79cceb9cf99 [detached]]
2018-12-13 08:54:41.374 INFO  [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Contact created: TELEPHONE: 0049817312
----

The log entries now contain the following part of the message: `[Pet: 205]`. This context entry is also used for CUBA internal logging messages like the logging message of the `RdbmsStore`.

MDC has the following advantages over putting context values directly into the log message:

- log messages are homogeneous across all usages of logging
- log messages are structured allowing for explicit search
- the definition of the context can be extracted into a single place of the source code


== Logging to centralized Logging solution


== Summary



