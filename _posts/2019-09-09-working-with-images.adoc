---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-working-with-images
permalink: working-with-images
---
=  在 CUBA 应用程序中使用图片
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: 在 CUBA 应用程序中使用图片
:page-excerpt: 这个指南将探究 CUBA 应用程序中图片的几种使用方式
:page-icone: images/working-with-images/guide_icone.svg
:page-root: ../../../
:project_id: cuba-petclinic-working-with-images
:page-url-first-image: https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-working-with-images/master/img/login-screen.png
:java_version: 1.8
:cuba_version: 7.0


在 CUBA 应用程序中有几种使用图片的方式。在这个指南中会演示如何上传和显示图片。也演示了如何将图片附加到实体同时允许用户从应用程序中下载图片文件。

== 将要构建的内容


本指南对 https://github.com/cuba-platform/cuba-petclinic[CUBA 宠物诊所]示例进行了增强，允许用户附加图片到实体，并且使用这些图片。特定是进行了下列修改：

* 允许给兽医上传头像
* 在兽医浏览界面显示兽医的头像
* 创建了类似 lookup 的自定义组件，使用这个组件显示将兽医头像显示在姓名旁边 ????
* 允许给就诊记录附加 X-光照片，也可以查看这些照片

=== 最终应用程序

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-working-with-images/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-working-with-images/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]


== CUBA 文件存储子系统
CUBA 提供了一组综合性的功能用来在应用程序中处理文件。 底层子系统被称作  `文件存储`。


这组 API 为开发人员在文件处理方面提供了端对端（前端到后端）的功能实现：

* 用户上传文件的功能
* 在业务实体中保存文件引用
* 在应用程序中读&写文件
* 用户下载文件的功能

文件存储子系统从物理文件中分离出文件元数据，文件元数据存储在关系数据库，物理文件存储在文件系统。

关于这个主题的详细信息可参考文档：https://doc.cuba-platform.com/manual-{cuba_version}/file_storage.html[文件存储] 。

由于图片是一种比较特别的文件类型，所以对于图片文件的处理加入了一些特殊的额外行为，比如在浏览器中预览图片。


image::working-with-images/vet-avatar-example.png[width=200,float="right"]


== 兽医头像图片

本指南的第一个示例是允许用户上传并显示特定兽医的头像图片。

要实现这个功能，宠物诊所示例中的数据模型需要进行一些改进，以便在 `Vet` 实体中存储文件引用。 CUBA  内置的对应 JPA 实体是 `FileDescriptor` 。 它存储文件的元数据部分， 同时作为指向物理文件的指针。

关系类型是 `MANY-TO-ONE` 。在 Studio 的实体设计器中结果看起来是这样：

image::working-with-images/vet-entity-file-descriptor-reference.png[align="center",link="/guides/images/working-with-images/vet-entity-file-descriptor-reference.png"]

由于实体模型包含对 `FileDescriptor`  实体的引用，属性 `image` 必须被添加到视图中，以便在 UI 中使用这个属性。

实体的 `vet-with-specialties`  视图在兽医(Vet)编辑界面使用，必须修改成包含 `image` 属性：


.views.xml
[source,xml]
----
<view class="com.haulmont.sample.petclinic.entity.vet.Vet"
      extends="_local"
      name="vet-with-specialties-and-image">
    <property name="specialties"
              view="_minimal"/>
    <property name="image" view="_base" />
</view>
----

进行了这个调整后有必要将视图重命名为  `vet-with-specialties-and-image` ，以反映出视图内容。


=== 上传兽医头像

满足了上述先决条件后，下一步是调整兽医编辑界面，以允许在创建或编辑兽医记录时可以上传图片。

CUBA  有一个内置的用于处理 `FileDescriptor`  实例的 UI 组件。这个组件可以添加到 `vet-edit.xml` 界面描述文件中的 `<form />` 表单组件中。

.vet-edit.xml
[source,xml]
----
<form id="fieldGroup" dataContainer="vetDc">
    <column width="250px">

        <textField property="firstName"/>
        <textField property="lastName"/>

        <upload id="imageField"
                property="image" // <1>
                fileStoragePutMode="IMMEDIATE"
                showFileName="true"
        />

    </column>
</form>
----

<1> FileUploadField 组件将上传的文件绑定到 `vetDc`  数据容器的  `image`  属性

有几个控制上传组件行为的选项，可在这里找到： https://doc.cuba-platform.com/manual-{cuba_version}/gui_FileUploadField.html[参考文档] 。在当前案例中，使用默认行为就可以了。它允许用户上传、下载、移除和重新上传文件，并且直接将文件附加到编辑界面上的 Vet 实例。

最终用户界面看下来是这样：

image::working-with-images/vet-entity-file-descriptor-reference-ui.png[align="center"]

`fileStoragePutMode` 属性设置为 `IMMEDIAT`  时，文件上传完成后会被持久化并且直接创建一个 `FileDescriptor` 实体实例。这种方式的好处是 Vet 实例会和图片直接关联起来，不需要额外的编程处理。


但是，这种方式有一个副作用： 在 Vet 实例没有保存的情况下，文件仍然会被保存到文件系统。这个文件也可以通过 `Administration > External Files` 功能查到。  如果这不是想要行为， 可以将 `fileStoragePutMode` 设置为 `MANUAL` ，这时就需要手动管理文件的持久化。 接下来的用例会描述这种行为的更多细节。


=== 在浏览表格中显示兽医的头像

下一个示例是处理上传的兽医头像图片，这个图片要显示在兽医浏览界面。要做到这点， `image`  属性应该出现在相应的视图（根据上面的视图修改而来）

在界面上显示图片的第二个 UI 组件是 `<image />` 组件。它允许使用各种来源来渲染一个图片，来源包括：

* 来自文件系统/classpath 的图片
* 来自任务 URL 的图片
* 来自 `FileDescriptor` 实例

参考 https://doc.cuba-platform.com/manual-{cuba_version}/gui_Image.html[CUBA 文档： 图片 UI 组件] 了解更多关于各种选项的信息。


在这种情况下，由于 `Vet` 通过 `image` 属性实例持有 `FileDescriptor` 的引用，所以可以直接渲染文件引用的图片。

最终 UI 看起来是这样：

image::working-with-images/vet-avatar-browse-screen.png[align="center", link="/guides/images/working-with-images/vet-avatar-browse-screen.png"]

`image`  属性应该是兽医表格中的一列，此外，这列应该渲染一个特定的图片，不应该是 `FileDescriptor` 实例的实例名，而是图片本身。

要实现这种效果，就需要在控制器中写一些代码。


`Table`  组件有一个特别的方法： `addGeneratedColumn` ，这个方法允许为特定的列定义一个组件来作为这个列的渲染器。 这个方法对于每个要显示的实体都调用一次，接受相应的实体实例作为参数。

.VetBrowse.java
[source,java]
----
public class VetBrowse extends StandardLookup<Vet> {

    @Inject
    protected GroupTable<Vet> vetsTable;

    @Inject
    protected UiComponents uiComponents;

    @Subscribe
    protected void onInit(InitEvent event) {
        vetsTable.addGeneratedColumn( // <1>
                "image",
                this::renderAvatarImageComponent
        );
    }

    private Component renderAvatarImageComponent(Vet vet) {
        FileDescriptor imageFile = vet.getImage(); // <2>
        if (imageFile == null) {
            return null;
        }
        Image image = smallAvatarImage();
        image.setSource(FileDescriptorResource.class)
                .setFileDescriptor(imageFile); // <4>

        return image;
    }

    private Image smallAvatarImage() {
        Image image = uiComponents.create(Image.class);  // <3>
        image.setScaleMode(Image.ScaleMode.CONTAIN);
        image.setHeight("40");
        image.setWidth("40");
        image.setStyleName("avatar-icon-small");
        return image;
    }
}
----
<1> 通过 `renderAvatarImageComponent` 方法在 `vetsTable` 表格中注册一个新的列： `image`
<2> 通过 `Vet`  实例的 `image` 属性获取到 `FileDescriptor`  引用
<3>  UI 基础设施 `uiComponents` bean 是编程方式创建 UI 组件的入口点
<4> Image 组件通过 `FileDescriptorResource`  变体类型绑定到 `FileDescriptor`

有了这些代码，就可以创建一个 Image 组件、配置好并绑定到 `FileDescriptor` 实例。使用 CSS 类 `avatar-icon-small`，图片就可以渲染成上面展示的效果。


=== 创建包含头像的兽医 Lookup 组件

兽医头像功能的最后一部分是就诊详情界面，在兽医姓名的旁边应该显示兽医的头像。

image::working-with-images/vet-avatar-example.png[width=300]

在这里需要以另外一种方式应用 image 组件，即将其作为 Visit 编辑界面的一部分放在 `<form />` 组件中。


实现这个功能的源码分由两部分组成：

* `VetEdit` 控制器协调自定义组件的创建和绑定
* `VetPreviewComponentFactory` 负责使用合适的布局创建上面显示的组件，并且绑定到  `InstanceContainer`  的指定字段


TIP: A dedicated factory class that defines how the component is created is just one possible option to structure the implementation. It has certain advantages to extract the creating of the component into a dedicated class like encapsulation, separation of concerns and the ability to re-use in other screens. +
 +
However, it is also possible to include the component creation logic directly into the controller. This variant can be seen as an example on how to structure business logic in the UI layer. More information about this topic can be found in https://www.cuba-platform.com/guides/create-business-logic-in-cuba[Create business logic in CUBA] guide.





The orchestration within the `VetEdit` controller looks like this:

.VisitEdit.java
[source,java]
----
public class VisitEdit extends StandardEditor<Visit> {

    @Inject
    protected Form treatingVetForm;

    @Inject
    protected InstanceContainer<Visit> visitDc;

    // ...

    @Subscribe
    protected void renderTreatingVetLayout(AfterShowEvent event) {

        VetPreviewComponentFactory vetPreviewComponentFactory =
            new VetPreviewComponentFactory( // <1>
                uiComponents,
                screenBuilders,
                messageBundle,
                this
            );

        Component vetPreview = vetPreviewComponentFactory.create(  // <2>
                visitDc,
                vet -> getEditedEntity().setTreatingVet(vet)
        );

        treatingVetForm.add(vetPreview); // <3>
    }
}
----
<1> a new `VetPreviewComponentFactory` instance is created with all the required dependencies passed to it
<2> `create` creates an instance of the desired Vet avatar image component
<3> the created component is attached to the `treatingVetForm` to render the vet avatar image


The `VetPreviewComponentFactory` code contains a little bit more code for correct positioning of the elements within the layout. The key points are listed below (the complete class can be found in the example project: https://github.com/cuba-guides/{project_id}/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/visit/visit/VetPreviewComponentFactory.java[VetPreviewComponentFactory.java]).


.VetPreviewComponentFactory.java
[source,java]
----
public class VetPreviewComponentFactory {

    private final UiComponents uiComponents;
    private final ScreenBuilders screenBuilders;
    private final FrameOwner frameOwner;

    public Component create( // <1>
            InstanceContainer<Visit> visitDc,
            Consumer<Vet> vetSelectionHandler
    ){
        return verticalLayout(
                vetImage(visitDc),
                horizontalLayout(
                        treatingVetName(visitDc),
                        editVetButton(vetSelectionHandler)
                )
        );
    }

    // ...

    private Image vetImage(InstanceContainer<Visit> visitDc) {

        Image image = uiComponents.create(Image.class);
        // ...
        image.setValueSource(
                new ContainerValueSource<>(visitDc, "treatingVet.image") // <2>
        );
        return image;
    }

    private Button editVetButton(Consumer<Vet> vetSelectionHandler) {

        LinkButton button = uiComponents.create(LinkButton.class);
        // ...
        button.setAction(
                new BaseAction("changeVet")
                .withHandler(event -> openVetLookup(event, vetSelectionHandler)) // <3>
        );
        return button;
    }

    private void openVetLookup(
            Action.ActionPerformedEvent event,
            Consumer<Vet> vetSelectionHandler
    ) {
        screenBuilders.lookup(Vet.class, frameOwner)
                .withOpenMode(OpenMode.DIALOG)
                .withSelectHandler(
                        vets -> vetSelectionHandler.accept(vets.iterator().next())
                )
                .show();
    }
}
----
<1> a vertical layout containing the image, a horizontal layout containing the name and an "Edit" button is created
<2> the `ValueSource` references the `image` attribute of the associated `treatingVet` for the data container
<3> the handler for the "Edit" button triggers the provided `vetSelectionHandler`, so the associated actions can be controlled from the outside of this factory method

With this, the final usage of the custom Vet display & selection for the Vet looks like this:

image::working-with-images/vet-selection-in-visit-edit.png[align="center", link="/guides/images/working-with-images/vet-selection-in-visit-edit.png"]


== X-Ray Images for Visits

The second use case covered in this guide is the ability to attach X-Ray images to a particular visit. Those X-Ray images should be displayed when selected on the Table. Further it should be possible to upload and download those images.

The precondition is another change in the data model. As before, for the `Vet` entity the `Visit` also needs a reference to the `FileDescriptor`, but this time it is a `MANY-TO-MANY` association. With this domain model change as well as the corresponding view adjustment in place, the three parts of uploading, previewing and downloading the X-Ray images can be tackled.

=== Upload X-Ray Images

The first step is to upload the X-Ray image to a particular `Visit` instance. For this the following `<upload />` component will be placed in the `<buttonsPanel />` component of the `xRayImagesTable`. Compared to the first use case, this time the `fileStoragePutMode` will be set to `MANUAL`. This gives more freedom in defining the persistence behavior which is required in this scenario.

.visit-edit.xml
[source,xml]
----
<upload id="upload"
        showClearButton="false"
        uploadButtonIcon="UPLOAD"
        uploadButtonCaption=""
        fileStoragePutMode="MANUAL" // <1>
        permittedExtensions=".png,.jpg,.pdf" // <2>
        dropZone="contentHBox" // <3>
        showFileName="false"/>
----
<1> the persistence operation will be handled manually by the controller in order to correctly display the image preview
<2> either images or PDF files are allowed to be uploaded
<3> the additional drop zone allows users to drag & drop files onto the table / preview component

The corresponding `VisitEdit` controller subscribes to the `FileUploadSucceedEvent` of the `upload` component, persists the file and adds the `FileDescriptor` to the `M:N` association of the visit instance.

.VisitEdit.java
[source,java]
----
public class VisitEdit extends StandardEditor<Visit> {

    @Inject
    protected CollectionPropertyContainer<FileDescriptor> xRayImagesDc;

    @Inject
    protected FileUploadField upload;

    @Inject
    protected DataContext dataContext;

    @Inject
    protected FileUploadingAPI fileUploadingAPI;

    @Subscribe("upload")
    protected void onUploadFileUploadSucceed(
            FileUploadField.FileUploadSucceedEvent event
    ) {
        FileDescriptor imageDescriptor = upload.getFileDescriptor(); // <1>

        try {
            fileUploadingAPI.putFileIntoStorage(upload.getFileId(), imageDescriptor); // <2>

            FileDescriptor savedImageDescriptor = dataManager.commit(imageDescriptor);
            newImageDescriptors.add(savedImageDescriptor);

            xRayImagesDc.getMutableItems().add(savedImageDescriptor); // <3>
            /* ... */
        } catch (FileStorageException e) {
            /* ... */
        }
    }
}
----
<1> the newly created `FileDescriptor` instance of the uploaded file is needed to persist the instance
<2> the uploaded file is transferred to the backend and persisted in the FileStorage
<3> the `FileDescriptor` instance for the already persisted file is assigned to the X-Ray images `M:N` association to display it in the table

WARNING: Besides the code in the listing, there is a little bit more relevant code in the example. It handles the case when the edit operation of the visit is cancelled by the user after uploading an image. In this case the images have to be removed again. For more information see the example: https://github.com/cuba-guides/cuba-petclinic-working-with-images/blob/master/modules/web/src/com/haulmont/sample/petclinic/web/visit/visit/VisitEdit.java[VisitEdit.java].

With that subscription code in place, the X-Ray image upload is implemented and can be used to fulfil the next step: preview of the uploaded images.

=== X-Ray Image Preview

In order to render an image preview of the uploaded X-Ray image, the `visit-edit.xml` needs to be adjusted so that it can display information next to the X-Ray images M:N table.

.visit-edit.xml
[source,xml]
----
<hbox id="contentHBox" spacing="true" width="100%">
    <table id="xRayImagesTable"
           dataContainer="xRayImagesDc"
           width="100%"
           height="100%"
           columnControlVisible="false">
        <actions>
            <action id="download" trackSelection="true" icon="DOWNLOAD"/>
            <action id="edit" type="edit"/>
            <action id="remove" type="remove"/>
        </actions>
        <columns>
            <column id="name"/>
        </columns>
    </table>
    <hbox id="xrayImageWrapperLayout"
          height="100%"
          width="100%"
          spacing="true">
    </hbox>
</hbox>
----

The most relevant part for this case is the `xrayImageWrapperLayout` component, which acts as a placeholder that will contain the image later. Currently it contains no child components, instead it will be dynamically filled at the time a selection is made for the `xRayImagesTable`.


.VisitEdit.java
[source,java]
----
public class VisitEdit extends StandardEditor<Visit> {

    @Inject
    protected Table<FileDescriptor> xRayImagesTable;

    @Subscribe("xRayImagesTable")
    protected void onXRayImagesTableSelection(
            Table.SelectionEvent<FileDescriptor> event
    ) {
        xrayImageWrapperLayout.removeAll();
        Set<FileDescriptor> selectedXrayImages = event.getSelected(); // <1>
        if (!selectedXrayImages.isEmpty()) {
            xrayImageWrapperLayout.add( // <2>
                    xrayImage(
                            selectedXrayImages.iterator().next()
                    )
            );
        }
    }

    private Component xrayImage(FileDescriptor file) {
        XrayPreviewComponentFactory factory = new XrayPreviewComponentFactory(
                uiComponents,
                messageBundle
        );

        return factory.create(file); // <3>
    }
}
----
<1> the table selection event is used to fetch the selected `FileDescriptor` instance (X-Ray image)
<2> an X-Ray component is placed within the `xrayImageWrapperLayout` as a child component for the selected X-Ray image
<3> the logic to create the X-Ray image preview component is delegated to the `XrayPreviewComponentFactory` class

Since the X-Ray image preview is also a composition of multiple elements, this logic was once again extracted into a dedicated `Factory` class. The resulting UI layout consists of a `GroupBox` which has the filename as the caption and the image preview as the content:


image::working-with-images/x-ray-image-component.png[align="center", width="600"]


The listing for the `XrayPreviewComponentFactory` contains only the most relevant parts. One important part of the functionality is that it should be able to render either Images or PDF files directly in the browser. This requires a branching logic within the implementation to use the correct UI component based on the file type.

.XrayPreviewComponentFactory.java
[source,java]
----
public class XrayPreviewComponentFactory {

    public Component create(FileDescriptor file) {
        GroupBoxLayout groupBoxLayout = uiComponents.create(GroupBoxLayout.class);
        groupBoxLayout.setShowAsPanel(true); // <1>
        groupBoxLayout.setStyleName("well");
        groupBoxLayout.setCaption(
                messageBundle.formatMessage("previewFile", file.getName())
        );
        if (isPdf(file)) {
            groupBoxLayout.add(xrayPdfComponent(file));
        }
        else if (isImage(file)){
            groupBoxLayout.add(xrayImageComponent(file));
        }
        return groupBoxLayout;
    }

    private boolean isPdf(FileDescriptor file) {
        return file.getExtension().contains("pdf");
    }

    // ...

    private Component xrayImageComponent(FileDescriptor imageFile) {
        Image image = uiComponents.create(Image.class);
        image.setScaleMode(Image.ScaleMode.SCALE_DOWN);
        image.setSource(FileDescriptorResource.class)
                .setFileDescriptor(imageFile); // <2>
        return image;
    }

    private Component xrayPdfComponent(FileDescriptor imageFile) {
        BrowserFrame browserFrame = uiComponents.create(BrowserFrame.class);
        browserFrame.setSource(FileDescriptorResource.class)
                .setFileDescriptor(imageFile)
                .setMimeType(MediaType.APPLICATION_PDF_VALUE); // <3>
        return browserFrame;
    }
}
----
<1> GroupBox specific styles will be applied to the wrapper component
<2> in case of an image, the `Image` component will be used and the `FileDescriptor` will be assigned as a source
<3> in case of a PDF file, the correct mime type has to be set in order to render the file in the browser inline

With those two parts in place, the preview functionality of the X-Ray Images is complete:

image::working-with-images/x-ray-image-preview.png[align="center", link="/guides/images/working-with-images/x-ray-image-preview.png"]


=== Download X-Ray Images

The last part of the X-Ray Image preview functionality use case is that it should be possible to download the image files.

To achieve this an additional `download` button and action are placed on top of the `xRayImagesTable`. The controller code uses the `ExportDisplay` bean from CUBA to trigger the download of a FileDescriptor in the browser.

.VisitEdit.java
[source,java]
----
public class VisitEdit extends StandardEditor<Visit> {

    @Inject
    protected ExportDisplay exportDisplay;

    @Subscribe("xRayImagesTable.download")
    protected void onXRayImagesTableDownload(Action.ActionPerformedEvent event) {
        downloadFile(xRayImagesTable.getSingleSelected());
    }

    private void downloadFile(FileDescriptor file) {
        exportDisplay.show(file, ExportFormat.OCTET_STREAM);
    }
}
----

The `exportDisplay` bean has multiple options to download a file. The one that is used here takes a `FileDescriptor` instance. `ExportFormat.OCTET_STREAM` indicates that the browser should force the file to be downloaded and not to try to render it within the browser.

== Summary

Image rendering within CUBA applications as well as custom composition of components will enrich the CRUD experience for users immediately. The main building block is the `FileDescriptor` abstraction that all UI components seamlessly integrate with.

In this guide two use cases were shown. The first one with the Vet avatar image used the standard upload functionality within a `<form />` component and rendered the result as a generated column within a table. Additionally a custom image-aware "PickerField" was created. The second use case used the APIs more directly to upload, preview and download X-Ray images for visits.


== Further Information

* https://doc.cuba-platform.com/manual-{cuba_version}/gui_FileUploadField.html[CUBA docs: File Upload UI component]
* https://doc.cuba-platform.com/manual-{cuba_version}/gui_Image.html[CUBA docs: Image UI component]
* https://www.cuba-platform.com/guides/create-business-logic-in-cuba[CUBA guide: Create business logic in CUBA]
