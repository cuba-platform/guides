---
compatible_cuba_versions: 7.1+
compatible_java_versions: 8+
project_id: cuba-petclinic-unit-testing
permalink: web-integration-testing
---
= Web Integration Testing in CUBA Applications
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Web Integration Testing in CUBA Applications
:page-excerpt: In this guide you will learn how automated testing in a CUBA application works. In particular this guide deals with the integration testing of the UI within the web layer.
:page-root: ../../../
:project_id: cuba-petclinic-testing-web
:java_version: 8
:cuba_version: 7.2
:page-icone: images/integration-testing-web/guide_icone.svg

In this guide you will learn how automated testing in a CUBA application works. In particular this guide deals with the integration testing of the UI within the web layer.

== What Will be Built

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA Petclinic] example to show how existing features can be tested in an automated fashion via unit testing:

* display amount of pets of a given pet type for a particular Owner
* calculation of next regular checkup date proposals for a pet

include::includes/guide_requirements.adoc[]

== Overview

In this third guide about testing you will learn how to test logic in the user interface. This is similar to the variant of middleware integration testing (see https://www.cuba-platform.com/guides/integration-testing-middleware[CUBA guide: middleware integration testing]), where a close-to-production test environment is created for the test to run.

The difference in this case is that the environment, which is provided only starts the part of a CUBA application that is inside the https://doc.cuba-platform.com/manual-latest/app_tiers.html[Client tier] of the architecture diagram.

image::integration-testing-web/AppTiers.svg[align="center"]

In particular the _Web client block_ is the part that is in this case marks the system under test (SUT).

The _Middleware block_ on the other side is _not_ part of the test environment. Instead Stub implementations are provided for all functionality that is part of that block. This includes the CUBA standard APIs like DataManager as well as custom Services that contain business logic.

== Web Integration Test Environment

In this environment the production application is started partially, just like in the middleware integration test. All the CUBA platform based UI APIs work the way just as in the production code of the application. In the _Web client block_ there is also a big part of declarative definitions of the UI via XML screen descriptors. This definitions are also covered and executed within the test environment.

=== Coverage Example

To understand this question of coverage let's take a look at one example within the Petclinic application and identify which parts are included, which ones are mocked and which ones are not covered at all. Coverage in this case does not mean that a test case explicitly loads the shown code and interacts with it, but more that by opening the Screen implicitly by the environment everything will be loaded and initialized, so that the test case is then able to interact with the Screen.

For this example let's take a look at the List of the Owners from the Petclinic. It consists of the XML descriptor part as well as the UI controller. In the following listing generally everything is covered and executed just as in the production environment. Therefore it is not mentioning everything that is covered, but only the most important parts as well as the parts where the coverage ends.

.pet-browse.xml
[source,xml]
----
<window>
    <data readOnly="true">
        <collection id="petsDc"
                    class="com.haulmont.sample.petclinic.entity.pet.Pet"
                    view="pet-with-owner-and-type-and-visits">
            <loader id="petsDl">
                <query>
                    <![CDATA[select e from petclinic_Pet e]]> // <1>
                </query>
            </loader>
        </collection>
    </data>
    <layout expand="petsTable"
            spacing="true">
        <groupTable id="petsTable"
                    dataContainer="petsDc"
                    width="100%">
            <actions>
                <action id="calculateDiscount"
                    trackSelection="true"
                    caption="msg://calculateDiscount"
                    icon="MONEY"
                  />
                  <action id="createDiseaseWarningMailing"
                    caption="msg://createDiseaseWarningMailing"
                    icon="font-icon:BULLHORN"
                  />
            </actions>
            <buttonsPanel id="buttonsPanel"
                          alwaysVisible="true">
                <button id="calculateDiscountBtn"
                        action="petsTable.calculateDiscount"
                        /> // <2>
                <button id="createDiseaseWarningMailingBtn"
                        action="petsTable.createDiseaseWarningMailing"/>
            </buttonsPanel>
        </groupTable>
    </layout>
</window>
----
<1> the data loading mechanism is available, but return values have to be manually returned in the test
<2> all buttons and actions are covered and can be performed

TIP: The test environment behaves almost like the production environment. The XML Screen descriptor is loaded and the complete lifecycle of the Screen is executed.

The main point of difference for the UI descriptor is the data loader section. Instead of performing the query against the database, the
environment of the web integration test requires to configure the entity instances that should be returned.

Next to the UI Screen descriptor, the programmatic sibling is the UI controller. Let's take a look at the coverage for
the corresponding PetBrowse UI controller:

.PetBrowse.java
[source,java]
----
public class PetBrowse extends StandardLookup<Pet> {
    @Inject
    private Screens screens; // <1>
    @Inject
    private Notifications notifications;
    @Inject
    private GroupTable<Pet> petsTable; // <2>

    @Subscribe("petsTable.calculateDiscount") // <3>
    public void calculateDiscount(
            Action.ActionPerformedEvent actionPerformedEvent
    ) {
        Pet pet = petsTable.getSingleSelected();

        String discountMessage = String.format(
                "Discount for %s: %s",
                pet.getName(),
                pet.calculateDiscount() // <4>
        );

        notifications.create(Notifications.NotificationType.TRAY)
            .withCaption(discountMessage)
            .show();
    }

    @Subscribe("petsTable.createDiseaseWarningMailing")
    public void createDiseaseWarningMailing(
            Action.ActionPerformedEvent actionPerformedEvent
    ) {
        screens
            .create(
                CreateDiseaseWarningMailing.class,
                OpenMode.DIALOG
            )
            .show(); // <5>
    }
}
----
<1> CUBA UI APIs are covered and working as in production environment
<2> UI Components injections that are defined in the XML Screen Descriptor are covered
<3> Action Subscriptions that interact with the XML Screen Descriptor are covered and performed in case a button is pressed in the test
<4> business logic in the `global` module (e.g. `pet.calculateDiscount()`) is part of the test environment as well
<5> the Screens API is performed correctly and the `CreateDiseaseWarningMailing` screen is opened

In the UI Controller it once again behaves very much like in the production environment. All injections (UI components and CUBA APIs)
work as expected. All business logic in the `web` and `global` modules are performed just as in the production environment.


=== Coverage of the Web integration test

Based on the example from above, you can coverage of the web integration test environment in this overview diagram:

image::integration-testing-web/coverage.svg[align="center"]

The solid arrows represent the connections that are part of the coverage, whereas the dashed arrows are the ones are not
covered and have to be mocked / emulated by the test case.

As explained before in the example, all Screen Controller code as well as the XML Screen descriptor definitions are covered.
Additionally all business logic that is located in the `web` and the `global` module is covered and executed.

On the upper border of the diagram the code that is executed in the browser is not part of the environment. This is all
JavaScript code that is part of Vaadin is not covered.

WARNING: The web integration test environment does _not_ interact with the application via a real web browser. To cover
this area in a test case, a functional end-to-end test through something like https://www.cuba-platform.com/marketplace/masquerade/[Masquerade] has to be performed.

The borders at the bottom of the layered diagram for the web integration test environment are the Middleware Services.
The service interfaces itself acts as the point where the test case has to provide a stub implementation that returns the expected values.

The same is true for the declarative data loading in the XML Screen descriptor. Internally the declarative data interaction
as well as the `DataManager` API uses the `DataService` Service to provide the data. This means inside the test case,
this `DataService` interface has to be replaced with a Stub implementation that provides the data that should be used
by the UI components. Detailed information about the `DataService` API can be found in the https://files.cuba-platform.com/javadoc/cuba/{cuba_version}/com/haulmont/cuba/core/app/DataService.html[CUBA API Reference: DataService]


=== Benefits & Limitations

Using Web integration tests allows developers to automatically verify the correctness of the majority of the UI screen
definition and its business logic. For the UI parts relying primarily on unit test would require to use a lot of mocking
of the CUBA UI APIs as well as letting go the verification of the declarative part.

We learned in the beginning that the web integration tests provide a close-to-production environment for the tests. This
means that for a lot of UI logic verification it is not necessary to run an end-to-end black box test case through the browser via Selenium e.g.

Automated Testing through the web browser is inherently more complex to do. The asynchronicity of the browser interaction,
the much more complicated test data setup, the speed of the execution are all examples of that.

Web integration tests do not have those problems. Instead running the tests is orders of magnitude faster compared to run
a selenium based test. A regular web integration test takes a sub second to run, whereas a Selenium based test easily can
take half a minute to perform the same operation. Also any kind of false positive test runs that oftentimes occur in a
selenium based test suite are not a problem of a web integration test. Those result due to the asynchronous nature of the browser
which is not used in this case.

On the other hand, there are limitations on what a web integration test can do and verify. By the fact that we have to stub
out data operations it is not possible to find a lot of scenarios that occur during that process. Here are some examples,
which are not able to catch during web integration tests:

* a unique violation on the order ID field through the save in the Order editor
* the customer name should be displayed in the orders table, but it is not part of the view
* the JPQL query in the orders data loader is a valid statement

For all those examples (and more) it is not possible to verify the behavior with an integration test.

The same is true for the correct interaction with custom Services that are used in the UI. As those Services are stubbed out
there is a potential to miss some scenarios in the mocking, which results in that the production application differs from
the web integration test behavior.

These limitations cannot be overcome with a web integration test. For that it requires a black-box end-to-end test case.
CUBA has a dedicated library called https://www.cuba-platform.com/marketplace/masquerade/[Masquerade] that makes creating
those test cases easier. It is based on Selenium and therefore performs real browser based tests that interacts with the
application from the UI to the database.


== Petclinic Web Integration Tests

After elaborating the theoretical ways on what a web integration test is and where its functionality boundaries are, lets
shift gears here a little bit and take a look at how a web integration test looks. We will do that based on the Petclinic
example.

=== First Web Integration Test


.PetEditorTest.java
[source,java]
----
public class OwnerBrowseTest {

    @RegisterExtension
    TestUiEnvironment environment =
            new TestUiEnvironment(PetclinicWebTestContainer.Common.INSTANCE)
                    .withScreenPackages(
                            "com.haulmont.cuba.web.app.main",
                            "com.haulmont.sample.petclinic.web"
                    )
                    .withUserLogin("admin");


    private Screens screens;
    private TestEntityFactory<Pet> petsFactory;

    @BeforeEach
    public void setUp() {
        petsFactory = environment.getContainer()
            .getEntityFactory(Pet.class, TestEntityState.NEW);

        screens = environment.getScreens();
        screens.create(MainScreen.class, OpenMode.ROOT).show();
    }

    @Test
    public void when_openingThePetEditor_then_theIdentificationNumberValueIsCorrectlyBoundInTheInputField() {

        Pet pet = petsFactory.create(
                Collections.singletonMap("identificationNumber", "019")
        );

        PetEdit petEdit = showPetEditorFor(pet);

        TextInputField identificationNumber = identificationNumberField(petEdit);

        assertThat(identificationNumber.getValue())
            .isEqualTo("019");
    }

    private PetEdit showPetEditorFor(Pet pet) {
        PetEdit petEdit = screens.create(PetEdit.class);
        petEdit.setEntityToEdit(pet);
        petEdit.show();
        return petEdit;
    }

    private TextInputField identificationNumberField(PetEdit petEdit) {
        return (TextInputField) petEdit
            .getWindow()
            .getComponent("identificationNumberField");
    }

}
----


=== Owner Browse

=== Create Disease Warning Mailing

== Sneferu

=== Overview

=== Create Disease Warning Mailing - Revisited


== Summary


== Further Information

* https://files.cuba-platform.com/javadoc/cuba/{cuba_version}/com/haulmont/cuba/core/app/DataService.html[CUBA API Reference: DataService]
* https://doc.cuba-platform.com/manual-latest/integration_tests_client.html[CUBA Documentation: Web Integration Tests]
