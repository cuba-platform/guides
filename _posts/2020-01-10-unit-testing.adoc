---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-unit-testing
permalink: unit-testing
---
= Unit Testing in CUBA Applications
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: Unit Testing in CUBA applications
:page-excerpt: In this guide you will learn how automated testing in a CUBA application works. In particular this guide deals with the question of how unit tests can be executed and when it makes sense to use them.
:page-root: ../../../
:project_id: cuba-petclinic-unit-testing
:java_version: 1.8
:cuba_version: 7.0
:page-icone: images/intro-to-reports/guide_icone.svg

In this guide you will learn how automated testing in a CUBA application works. In particular this guide deals with the question of how unit tests can be executed and when it makes sense to use them.

== What Will be Built

This guide enhances the https://github.com/cuba-platform/cuba-petclinic[CUBA Petclinic] example to show how existing features can be tested in an automated fashion via unit testing:

* calculation of next regular checkup date proposals for a Pet

=== Final Application

++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-reports/master/img/adjustments-cuba-petclinic-overview.gif"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-intro-to-reports/master/img/login-screen.png"/></a>
++++

include::includes/guide_requirements.adoc[]

include::includes/petclinic_introduction.adoc[]

== Overview

In this guides you will learn how to use the techniques of unit testing without dependencies. This approach differs from the previously discussed variant of middleware integration testing, where a close-to-production test environment is created for the test to run.

In case of unit testing, the test environment is very slim because basically no runtime of the CUBA framework is provided. In return for giving up this convenience, unit testing allows you to more easily spin up the system under test and bring it to the proper state it needs to be to exercise the test case. It also cuts out a whole lot of problems regarding test data setup and is generally executed faster by orders of magnitude.

=== Unit Testing

Besides the integration test environment that you learned about in the middleware integration testing guide, it is also possible to create test cases, that do not spin up the Spring application context or any CUBA platform APIs at all.

The main benefits of writing unit test in an isolated fashion without an integration test environment are:

* locality of the test scenario
* test execution speed
* easier test fixture setup

In this case the class under test is instantiated directly via its constructor.
Since Spring is not involved on managing the instantiation of the class, dependency injection is not working in this scenario. Therefore dependencies (objects that the class under test relies upon) have to be instantiated manually and passed into the class under test directly.

In case those dependencies are CUBA APIs, they normally have to be mocked.

=== Mocking

Mocking / Stubbing is a common way in test automation that helps to emulate / control & verify certain external parts that the system under test interacts with in order to isolate the SUT as much as possible from its outside world.

<< INSERT IMAGE WITH SUT & DOC mocked out >>

As seen in the picture there is one class that acts as the system that should be tested (system under test: SUT). This class uses another class that is responsible for helping some additional need. This class is normally referred to as dependent-on-component (DOC).

What Stubbing or Mocking is doing now is the following:

In order to isolate the SUT from any other component to gain the test locality, the DOC is replaced with a fake object. This object plays the role of the real DOC, but in the test case you control the behavior of the fake object. With that you can directly influence how the SUT behaves even if it has some interaction with another dependency that would otherwise not be controllable directly.

==== Mocking Frameworks

JUnit itself does not contain Mocking capabilities. Instead dedicated Mocking frameworks allow to instantiated fake objects and control their behavior in a JUnit test case. In this guide you will learn about Mockito, a very popular Stubbing / Mocking framework in the Java ecosystem.


==== An Example of Mocking

The following example shows how to configure a mock object. In this case it will replace the behavior of the `TimeSource` API from CUBA which allows to retrieve the current timestamp. In this case the mock object should return yesterday. The way to define the behavior of a fake object in a JUnit Test case with Mockito looks like this:


.MockingTest.java
[source,java]
----
@ExtendWith(MockitoExtension.class) // <1>
class MockingTest {

  @Mock
  private TimeSource timeSource; // <2>

  @Test
  public void theBehaviorOfTheTimeSource_canBeDefined_inATestCase() {
    // given:
    ZonedDateTime now = ZonedDateTime.now();
    ZonedDateTime yesterday = now.minusDays(1);
    // and: the timeSource Mock is configured to return yesterday when now() is called
    Mockito
        .when(timeSource.now())
        .thenReturn(yesterday); // <3>
    // when: the current time is retrieved from the TimeSource Interface
    ZonedDateTime receivedTimestamp = timeSource.now(); // <4>
    // then: the received Timestamp is not now
    assertThat(receivedTimestamp)
        .isNotEqualTo(now);
    // but: the received Timestamp is yesterday
    assertThat(receivedTimestamp)
        .isEqualTo(yesterday);
  }
}
----
<1> The `MockitoExtension` activates the automatic instantiation of the `@Mock` annotated attributes
<2> the `TimeSource` instance is marked as a `@Mock` and will be instantiated via Mockito
<3> the Mock behavior is defined in the test case
<4> invoking the method `now` returns yesterday instead of the correct value

With that behavior description in place, the one thing left is that the fake object instance is now manually injected into the class / system under test.



== Tests for Petclinic Functionality

Next you will see the different examples on how to use the unit test capabilities in order to automatically test the functionality of the Petclinic example project.

=== Next Regular Checkup Date Proposal

The first example is a functionality for the Petclinic project that allows the user to retrieve the information when the next regular checkup should be scheduled for a selected Pet. The next regular Checkup Date is calculated based on a couple of factors. The pet type determines the interval as well as when the last regular checkup has taken place.

The calculation is executed from the UI in the Pet browse screen. The proposed Date should be taken into consideration when creating


== Summary


== Further Information

* https://doc.cuba-platform.com/reporting-7.0/index.html[CUBA docs: Reporting]
* https://doc.cuba-platform.com/reporting-7.1/open_office.html[CUBA docs: Reporting - Appendix A: Installing and Configuring OpenOffice]
