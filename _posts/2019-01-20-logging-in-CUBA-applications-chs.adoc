---
compatible_cuba_versions: 7.0+
compatible_java_versions: 8+
project_id: cuba-petclinic-application-logging
permalink: logging-in-cuba-applications
---
= CUBA 应用程序日志
:showtitle:
:sectlinks:
:sectanchors:
:page-navtitle: 在 CUBA 应用程序中使用日志
:page-excerpt:  关于为什么及如何在 CUBA 应用程序中使用日志以获得洞见力
:page-root: ../../../
:project_id: cuba-petclinic-application-logging
:java_version: 1.8
:cuba_version: 7.0


要深入了解运行中的CUBA应用程序，记录日志是一种重要的手段。 Java生态系统具有非常成熟的应用程序日志记录机制。这个指南介绍了如何在CUBA应用程序中利用这个生态系统。

==  将要构建的内容

这个指南对 https://github.com/cuba-platform/cuba-petclinic[CUBA 宠物医院]示例进行了增强，以演示如何在 CUBA 应用程序中集成、配置日志功能，也演示了如何在CUBA 应用程序中查看日志或使用外部工具查看日志。



include::includes/guide_requirements.adoc[]


include::includes/petclinic_introduction.adoc[]


== 为什么应用程序日志是必须的

日志记录对于了解应用程序行为是必须的，通过日志可以看出应用程序出现了哪些异常行为、分析出用户如何与系统进行交互。

日志是应用程序开发及运营的基本工具。 开发人员在代码中加入语句以标记出特定动作的发生。

在下面的宠物诊所示例中，两个可能的日志消息会被写入。在成功地保存了 `Pet` 实例后，会记录一条包含宠物详情的常规消息。在保存失败时，会记录一条包含失败信息的错误级消息。



.PetServiceBean.java
[source,java]
----
private Pet savePet(Pet pet) {
    try {
        Pet savedPet = dataManager.commit(pet);
        log.info("Pet " + pet + " was saved correctly");
        return savedPet;
    } catch (Exception e) {
        log.error("Pet " + pet + " could not be saved", e);
        return null;
    }
}
----

日志消息会被保存到配置好的位置，管理员或开发人员会从这些位置访问日志消息。  通常，日志消息被保存到一个文本文件，但也有可能会保存到数据库或一个中心化的日志服务。

在应用程序开发阶段，开发人员可以随时挂起应用程序的执行来查看应用程序的内部状态。

对于已经上线运行的应用程序，通常不能这样做。这可能是因为安全问题或应用程序运行在不受开发人员控制的服务器上。

因此记录日志成为开发人员诊断应用程序问题的一个必备工具。

== Java 日志生态系统

在 Java 生态系统（也包括其它生态系统）中日志扮演着一个重要的角色。在 Java 生态系统中有各种各样的关于与应用程序所运行的平台的日志机制进行交互的机制和概念。


Mainly these are various APIs of the JVM and different logging libraries that encapsulate the technical concern of logging to a file / database from the abstraction of "writing a log message".

在最近几年，一个常用的组合被 Java 生态采纳，成为一个事实标准。

- Slf4J
- Logback

Slf4J 是一个抽象的 API，封装了日志库的创建细节。它为不同严重级别（`DEBUG` 、 `INFO` 、 `WARN` 等）的消息提供了不同的方法，这些方法将消息存储到日志系统。

Logback ,可以说是实现了那套 API 的日志库，最终，日志的实际输出是由它执行的。 在 Logback 中使用 Appender 的概念表示一个输出通道，一个 Appender 是一个日志库中的组件，它获取由应用程序开发人员创建的日志事件并将日志事件写入特定的输出目标。Logback 包提供了一些选项，通过这些选项可以配置日志系统的某些行为，比如哪些信息应该写到哪些输出通道（appender）。



== 在 CUBA 应用程序中如何记录日志

CUBA 应用程序中日志库的用法与其它Java 应用程序没有区别。 CUBA 默认适当地配置了 Sl4fJ 和 Logback 。 框架本身使用它们来记录框架内部的日志消息。

要在一个类里面记录信息，需要在这个类上创建一个 Logger 类的实例。


.DiseaseWarningMailingServiceBean.java
[source,java]
----
@Service(DiseaseWarningMailingService.NAME)
public class DiseaseWarningMailingServiceBean implements DiseaseWarningMailingService {

    private static final Logger log = LoggerFactory.getLogger(DiseaseWarningMailingServiceBean.class); // <1>

    // ...

    @Override
    public int warnAboutDisease(PetType petType, String disease, String city) {

        log.debug("Disease warnings should be send out for Pet type: {}, Disease: {} in the area of {}", petType, disease, city); // <2>

        List<Pet> petsInDiseaseCity = findPetsInDiseaseCity(petType, city);
        List<Pet> petsWithEmail = filterPetsWithValidOwnersEmail(petsInDiseaseCity);

        log.debug("possible pets in danger: {}", petsWithEmail);

        petsWithEmail.forEach(pet -> sendEmailToPetsOwner(pet, disease, city));
        int amountOfInformedPets = petsWithEmail.size();

        log.info("Summary: Disease warning send out to {} Pet(s) in {}", amountOfInformedPets, city); // <3>

        return amountOfInformedPets;
    }

    // ...
}
----
<1>  给这个类配置的 Logger 是由Slf4J 定义的
<2>  `warnAboutDisease`  初始化后记录调试日志消息
<3>  记录方法执行结果的摘要信息。消息中的可变部分可以传递给方法参数并且在日志消息中使用 `{}` 点位符标记出来

=== 通过 CUBA UI 查看日志消息

有几种方法可以访问正在运行的应用程序的日志输出。 最常见的方法是直接访问服务器上的日志文件。不幸的是，这通常需要特殊的权限和知识才能访问该文件。


CUBA 提供了一个用户界面，可以用来查看应用程序的运行时日志信息。 可以通过 `Administration > Server Log > View` 菜单打开这个界面：


++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-messages.png"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-messages.png"/></a>
++++

在这个界面上可以显示不同的日志文件，也可以将日志文件下载下来。这个功能给了非管理员角色访问日志的权限，同时仍然可以限制哪些角色允许访问日志。


=== 日志级别

要记录的信息在多个维护有不同类型。为了帮助消息的使用者能快速地区分出有用信息和无用信息， 所有的日志库都提供了一个非常重要的对消息进行分类的维度：日志级别。

日志级别可以表示出消息的重要/紧急程度。请注意，日志级别是按顺序排列的。 Slf4J  定义了下列可用在应用程序中的 https://www.slf4j.org/api/org/apache/log4j/Level.html[日志级别]

- TRACE
- DEBUG
- INFO
- WARN
- ERROR
- FATAL

`DEBUG`  日志消息一般用于帮助开发员标识应用程序的内部状态。

`ERROR` 和  `FATAL`  通常用于应用程序发生了非预期异常，并且不能再继续运行的情况。


== 调整日志配置

Logback (alongside with other logging libraries) allows customization on how and where the log information is processed and written to the output, mainly through the already mentioned `appender` concept.

Generally there are two options to adjust the configuration of logback. On the one side, there is a configuration file called `logback.xml` where the configuration can be expressed. These adjustments happen at deployment time. Alternatively, logback can (to a certain extent) be configured at runtime. CUBA offers a UI for adjusting logging configuration for this purpose (`Administration > Server Log > Options`).

=== At Deployment: logback.xml Configuration File

The configuration file `logback.xml` is the main place to adjust the configuration of logback. In a CUBA application this file is located in `deploy/tomcat/conf/logback.xml` (in case of https://doc.cuba-platform.com/manual-{cuba_version}/fast_deployment.html[fast deployment] option). It looks like this:


.logback.xml
[source,xml]
----
<configuration debug="false" packagingData="true">

    <property name="logDir" value="${catalina.base}/logs"/> // <1>

    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender"> // <2>
        <file>${logDir}/app.log</file>

        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>DEBUG</level>
        </filter>

        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread%X{cubaApp}%X{cubaUser}] %logger - %msg%n</pattern> // <3>
        </encoder>
    </appender>

    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender"> // <4>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %-5level %-40logger{36}- %msg%n</pattern>
        </encoder>
    </appender>

    <root>
        <appender-ref ref="Console"/>
        <appender-ref ref="File"/>
    </root>

    <logger name="com.haulmont.sample.petclinic" level="DEBUG"/> // <5>
    <logger name="com.haulmont.cuba" level="DEBUG"/>
    <logger name="com.haulmont.cuba.core.sys" level="INFO"/>

    <!-- ... -->

</configuration>
----
<1> `logDir` is a variable defined for the configuration, it describes where the file-based log files should be placed. It uses a special variable `catalina.base` from tomcat to reference the installation directory
<2> A file appender to write log messages to the logfile `app.log`
<3> `pattern` configures how a single log message line within the file should look like
<4> Another appender writes the log messages to `STDOUT` (with different options)
<5> Logging levels can be configured on a per class / package basis

CUBA by default configures multiple log appenders. An appender describes where the log information should be written to. There are multiple appenders available out of the box. Each appender has options to configure its behavior (like how the log message should be formatted, which information should be logged etc.). Common Log appenders are `FileAppender` and `ConsoleAppender`.

The configuration of loggers allows defining the threshold on a per class / package basis. This means that for certain sub-parts of the application, it is possible to get log messages that have been written as `DEBUG` while for other parts it is only necessary to see log messages of `WARN` and `ERROR`.

In the example above the package `com.haulmont.sample.petclinic` is set to level `DEBUG`. This means that it will output all log messages that have _at least_ the `DEBUG` level. Due to the semantic order of the log levels `INFO`, `WARN`, `ERROR` and `FATAL` will also be logged for this package. `TRACE` log messages, on the other hand, will not be displayed.

Depending on how the application is deployed there are several options on where to place the logback.xml file. Besides the above mentioned https://doc.cuba-platform.com/manual-{cuba_version}/fast_deployment.html[fast deployment], the `logback.xml` can be placed within the application itself or configure it to be outside of the application at a given path. See <<Further Information>> for more information.

=== At Runtime: CUBA Logging UI

Adjusting the configuration of the file requires a restart of the application. For temporary debugging sessions, it is oftentimes helpful not to have to restart the server only to adjust the logging level or a certain subpart of the application code.

For this use-case, a CUBA application allows reconfiguring the levels of existing loggers and also add loggers at runtime through a user interface.


++++
<a href="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-settings.png"><img src="https://raw.githubusercontent.com/cuba-guides/cuba-petclinic-application-logging/master/img/cuba-server-log-settings.png"/></a>
++++


=== Set Logging Context with MDC

Once the application has a certain amount of logging information certain information gets repeated in a lot of logging messages. In the petclinic example, a lot of log messages would contain the Pet ID in order to get the context information in a fast manner. For those kinds of information, there is a context in Logback, called _MDC_.

MDC allows setting certain values into a context, that gets logged every time alongside with the actual logging message. This way the context can be set once and the developer writing the actual logging statement does not need to include it into the log message anymore.

CUBA itself uses MDC in order to attach different context values to the logging messages. Mainly those are the current user as well as the current application. This means that the resulting logging messages can be filtered by users.

In the example of the petclinic, the `PetContactFetcherBean` leverages the MDC context in the following manner: directly after invoking the method `Optional<Contact> findContact(Pet pet)` the identification number of the Pet is set into the MDC context like this:


.PetContactFetcherBean.java
[source,java]
----
@Component(PetContactFetcher.NAME)
public class PetContactFetcherBean implements PetContactFetcher {

    private static final Logger log = LoggerFactory.getLogger(PetContactFetcherBean.class);

    @Override
    public Optional<Contact> findContact(Pet pet) {

        MDC.put("petId", pet.getIdentificationNumber()); // <1>

        log.debug("Searching Contact for Pet"); // <2>

        try {
            Optional<Owner> petOwner = loadOwnerFor(pet);

            if (petOwner.isPresent()) {
                log.debug("Found Owner: {}", petOwner);

                // ...

                if (isAvailable(telephone)) {
                    return createContact(telephone, ContactType.TELEPHONE);
                }

                // ...

            } else {
                return Optional.empty();
            }
        } finally {
            MDC.remove("petId"); // <4>
        }
    }

    private Optional<Contact> createContact(String contactValue, ContactType contactType) {

        Contact contact = new Contact();
        contact.setValue(contactValue);
        contact.setType(contactType);

        log.info("Contact created: {}", contact); // <3>

        return Optional.of(contact);
    }

    // ...
}
----
<1> The Pet's identification number is registered in the context under the key `petId`
<2> The following logging messages do not need to include the Pet ID within the log message itself
<3> The lifetime of value in the MDC is independent of method boundaries
<4> The key `petId` of the MDC is cleaned up at the end of the method


Now that the MDC has values in it, the next step is to reconfigure logback in order to see the dedicated MDC values in the log output.


.logback.xml
[source,xml]
----
<configuration debug="false" packagingData="true">

    <!-- ... -->

    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender">

        <!-- ... -->

        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread%X{cubaApp}%X{cubaUser}] [Pet: %X{petId}] %logger - %msg%n</pattern> // <1>
        </encoder>

    </appender>

    <!-- ... -->

</configuration>
----
<1> `%X{petId}` takes the value with the key `petId` of the MDC and writes it to the log file


The resulting logging output contains the Pet identification number:

[source,bash]
----
2018-12-13 08:54:41.345 DEBUG [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Searching Contact for Pet
2018-12-13 08:54:41.354 DEBUG [http-nio-8080-exec-7/petclinic-core/admin] [Pet: 205] c.h.c.c.a.RdbmsStore - load: metaClass=petclinic_Owner, id=79fa17b9-a130-207d-5091-f79cceb9cf99, view=com.haulmont.sample.petclinic.entity.owner.Owner/_local
2018-12-13 08:54:41.371 DEBUG [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Found Owner: Optional[com.haulmont.sample.petclinic.entity.owner.Owner-79fa17b9-a130-207d-5091-f79cceb9cf99 [detached]]
2018-12-13 08:54:41.374 INFO  [http-nio-8080-exec-7/petclinic/admin] [Pet: 205] c.h.s.p.c.PetContactFetcherBean - Contact created: TELEPHONE: 0049817312
----

The log entries now contain the following part of the message: `[Pet: 205]`. This context entry is also used for CUBA internal logging messages like the logging message of the `RdbmsStore`.

MDC has the following advantages over putting context values directly into the log message:

- log messages are homogeneous for all logging messages
- log messages are structured allowing for explicit search
- the definition of the context can be extracted into a single place of the source code


== Logging to Centralized Logging Solution

Having very detailed information about the execution of the running application is very important. But having to deal with a huge amount of log data is challenging. Storing this information in the filesystem of the server is not very accessible and also not very efficient to work with. This is why oftentimes centralized logging solutions are used for storing and accessing the log information.

A very common open source centralized logging system is based on Elasticsearch - a full-text search data store that turned out to be a great fit for the logging use case.

Logback integrates easily with centralized logging solutions via the concept of appender. In the configuration file, there were already two appenders configured for the application: `ConsoleAppender` and `FileAppender`.

For Elasticsearch there is a Logback Appender, that will directly send the logging information to the elasticsearch cluster instead of putting the log messages into a file. There are different options on how to configure logging to Elasticsearch (aka ELK-Stack). As this guide mainly deals with the integration with Logback within the application, configuring the Elasticsearch server in a production-ready way is out of scope.

In order to use Elasticsearch as a log storage backend, a dependency needs to be added to the CUBA application. In the `build.gradle` file the following dependency has to be added to _all_ modules: `runtime "com.internetitem:logback-elasticsearch-appender:1.6"`

The `logback.xml` configuration file should be extended to contain an additional appender:

.logback.xml
[source,xml]
----
<configuration debug="false" packagingData="true">

    <!-- ... -->

    <appender name="elasticsearch" class="com.internetitem.logback.elasticsearch.ElasticsearchAppender"> // <1>
        <url>${ELASTICSEARCH_CLUSTER_URL}</url> // <2>
        <index>cuba-petclinic-logs-%date{yyyy-MM-dd}</index> // <3>
        <type>cuba-petclinic</type>
        <errorLoggerName>es-error-logger</errorLoggerName>
        <includeMdc>true</includeMdc>
        <properties>
            <property>
                <name>host</name>
                <value>${HOSTNAME}</value>
                <allowEmpty>false</allowEmpty>
            </property>
            <property>
                <name>severity</name>
                <value>%level</value>
            </property>
            <property>
                <name>thread</name>
                <value>%thread</value>
            </property>
            <property>
                <name>logger</name>
                <value>%logger</value>
            </property>
            <property>
                <name>stacktrace</name>
                <value>%ex</value>
            </property>
        </properties>
    </appender>

    <!-- ... -->

</configuration>
----
<1> An `elasticsearch` appender of `ElasticsearchAppender` type is registered for the application
<2> The URL of the elasticsearch cluster is extracted from the environment variables
<3> The elasticsearch index for the application logs is `cuba-petclinic-logs-%date{yyyy-MM-dd}` with a daily rotation

With that configuration in place, the application will take the log messages and send them to elasticsearch. Kibana as a user interface for accessing data in elasticsearch is capable of displaying the log information properly. Via the structured as well as full-text search capabilities, the log information can be accessed in a much easier way compared to direct access to the log files.


image::application-logging-in-cuba/elasticsearch-kibana-ui-logging.png[Elasticsearch Kibana UI logging, link="images/application-logging-in-cuba/elasticsearch-kibana-ui-logging.png"]

== Summary

Logging is an essential part for developers and administrators to reason about a running application. It enables developers to observe a system through opening up the "black-box" and getting valuable insights. The use cases go from debugging over performance analysis to observing user behavior.

The logging facilities in the Java and CUBA ecosystem are very mature and can be used without any friction. But as the logging API is so generic and usable in multiple ways, it heavily depends on conventions in order to get qualitative logging messages in the application. There are different mechanisms to not get overwhelmed by raw logging messages through proper logging configuration, diagnosis contexts (MDC) and logging levels.

CUBA offers an opinionated way of dealing with logging configuration and access to logs. But as it is based on standard Java logging mechanism it plays nicely with other solutions like centralized logging systems.


== Further Information

* https://blog.scalyr.com/2017/12/logging-levels/[Blog article: Explanation of Logging levels]
* https://doc.cuba-platform.com/manual-{cuba_version}/logging_setup_tomcat.html[CUBA docs: Setup Logging for local development]
* https://doc.cuba-platform.com/manual-{cuba_version}/log_dir.html[CUBA docs: Log directory of CUBA application]
* https://doc.cuba-platform.com/manual-{cuba_version}/build.gradle_buildWar.html[CUBA docs: Build WAR with logging configuration]
